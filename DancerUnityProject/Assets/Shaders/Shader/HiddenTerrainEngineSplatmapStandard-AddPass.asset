%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!48 &4800000
Shader:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_Name: 
  serializedVersion: 2
  m_ParsedForm:
    m_PropInfo:
      m_Props: []
    m_SubShaders:
    - m_Passes:
      - m_NameIndices:
          : 0
          DIRECTIONAL: 1
          FOG_LINEAR: 5
          LIGHTPROBE_SH: 2
          SHADOWS_SCREEN: 3
          VERTEXLIGHT_ON: 4
          _NORMALMAP: 6
        m_Type: 0
        m_State:
          serializedVersion: 2
          m_Name: FORWARD
          rtBlend0:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 1
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 1
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend1:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend2:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend3:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend4:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend5:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend6:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend7:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtSeparateBlend: 0
          zClip:
            val: 1
            name: <noninit>
          zTest:
            val: 4
            name: <noninit>
          zWrite:
            val: 0
            name: <noninit>
          culling:
            val: 2
            name: <noninit>
          offsetFactor:
            val: 0
            name: <noninit>
          offsetUnits:
            val: 0
            name: <noninit>
          alphaToMask:
            val: 0
            name: <noninit>
          stencilOp:
            pass:
              val: 0
              name: <noninit>
            fail:
              val: 0
              name: <noninit>
            zFail:
              val: 0
              name: <noninit>
            comp:
              val: 0
              name: <noninit>
          stencilOpFront:
            pass:
              val: 0
              name: <noninit>
            fail:
              val: 0
              name: <noninit>
            zFail:
              val: 0
              name: <noninit>
            comp:
              val: 8
              name: <noninit>
          stencilOpBack:
            pass:
              val: 0
              name: <noninit>
            fail:
              val: 0
              name: <noninit>
            zFail:
              val: 0
              name: <noninit>
            comp:
              val: 8
              name: <noninit>
          stencilReadMask:
            val: 255
            name: <noninit>
          stencilWriteMask:
            val: 255
            name: <noninit>
          stencilRef:
            val: 0
            name: <noninit>
          fogStart:
            val: 0
            name: unity_FogStart
          fogEnd:
            val: 0
            name: unity_FogEnd
          fogDensity:
            val: 0
            name: unity_FogDensity
          fogColor:
            x:
              val: 0
              name: <noninit>
            y:
              val: 0
              name: <noninit>
            z:
              val: 0
              name: <noninit>
            w:
              val: 0
              name: <noninit>
            name: unity_FogColor
          fogMode: -1
          gpuProgramID: 25320
          m_Tags:
            tags:
              IGNOREPROJECTOR: true
              LIGHTMODE: FORWARDBASE
              QUEUE: Geometry-99
              RenderType: Opaque
              SHADOWSUPPORT: true
          m_LOD: 0
          lighting: 0
        m_ProgramMask: 6
        progVertex:
          m_SubPrograms:
          - serializedVersion: 3
            m_BlobIndex: 0
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 1
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000200
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 2
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 3
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010002000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 4
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000400
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 5
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010002000400
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 8
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 6
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010003000400
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 7
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100020003000400
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 8
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 8
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000500
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 9
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010005000200
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 10
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010005000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 11
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100050002000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 12
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010005000400
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 13
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100050002000400
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 8
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 14
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100050003000400
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 15
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000500020003000400
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 8
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 16
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 17
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010002000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 18
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010003000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 19
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100020003000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 20
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010004000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 21
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100020004000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 8
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 22
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100030004000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 23
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000200030004000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 8
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 24
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010005000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 25
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100050002000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 26
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100050003000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 27
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000500020003000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 28
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100050004000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 29
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000500020004000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 8
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 30
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000500030004000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 31
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010005000200030004000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 8
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
        progFragment:
          m_SubPrograms:
          - serializedVersion: 3
            m_BlobIndex: 32
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0100
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 240
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 33
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 01000200
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 240
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 624
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 640
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 656
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 34
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 01000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 35
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 010002000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 624
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 640
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 656
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 36
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 01000500
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 240
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 37
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 010005000200
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 240
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 624
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 640
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 656
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 38
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 010005000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            - m_NameIndex: 0
              m_Index: 6
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 39
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0100050002000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 624
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 640
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 656
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            - m_NameIndex: 0
              m_Index: 6
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 40
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 01000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 41
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 010002000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 624
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 640
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 656
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 42
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 010003000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 260
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 264
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 268
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 272
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 43
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0100020003000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 260
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 264
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 268
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 272
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 624
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 640
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 656
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 44
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 010005000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 45
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0100050002000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 624
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 640
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 656
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 46
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0100050003000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 260
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 264
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 268
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 272
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            - m_NameIndex: 0
              m_Index: 6
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 47
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 01000500020003000600
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: -1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 260
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 264
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 268
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 272
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 624
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 640
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 656
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 48
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 128
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            - m_NameIndex: 0
              m_Index: 6
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
        progGeometry:
          m_SubPrograms: []
        progHull:
          m_SubPrograms: []
        progDomain:
          m_SubPrograms: []
        progRayTracing:
          m_SubPrograms: []
        m_HasInstancingVariant: 0
        m_HasProceduralInstancingVariant: 0
        m_UseName: 
        m_Name: 
        m_TextureName: 
        m_Tags:
          tags: {}
      - m_NameIndices:
          : 0
          DIRECTIONAL: 2
          DIRECTIONAL_COOKIE: 5
          FOG_LINEAR: 10
          POINT: 1
          POINT_COOKIE: 4
          SHADOWS_CUBE: 9
          SHADOWS_DEPTH: 6
          SHADOWS_SCREEN: 8
          SHADOWS_SOFT: 7
          SPOT: 3
          _NORMALMAP: 11
        m_Type: 0
        m_State:
          serializedVersion: 2
          m_Name: FORWARD
          rtBlend0:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 1
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 1
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend1:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend2:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend3:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend4:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend5:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend6:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend7:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtSeparateBlend: 0
          zClip:
            val: 1
            name: <noninit>
          zTest:
            val: 4
            name: <noninit>
          zWrite:
            val: 0
            name: <noninit>
          culling:
            val: 2
            name: <noninit>
          offsetFactor:
            val: 0
            name: <noninit>
          offsetUnits:
            val: 0
            name: <noninit>
          alphaToMask:
            val: 0
            name: <noninit>
          stencilOp:
            pass:
              val: 0
              name: <noninit>
            fail:
              val: 0
              name: <noninit>
            zFail:
              val: 0
              name: <noninit>
            comp:
              val: 0
              name: <noninit>
          stencilOpFront:
            pass:
              val: 0
              name: <noninit>
            fail:
              val: 0
              name: <noninit>
            zFail:
              val: 0
              name: <noninit>
            comp:
              val: 8
              name: <noninit>
          stencilOpBack:
            pass:
              val: 0
              name: <noninit>
            fail:
              val: 0
              name: <noninit>
            zFail:
              val: 0
              name: <noninit>
            comp:
              val: 8
              name: <noninit>
          stencilReadMask:
            val: 255
            name: <noninit>
          stencilWriteMask:
            val: 255
            name: <noninit>
          stencilRef:
            val: 0
            name: <noninit>
          fogStart:
            val: 0
            name: unity_FogStart
          fogEnd:
            val: 0
            name: unity_FogEnd
          fogDensity:
            val: 0
            name: unity_FogDensity
          fogColor:
            x:
              val: 0
              name: <noninit>
            y:
              val: 0
              name: <noninit>
            z:
              val: 0
              name: <noninit>
            w:
              val: 0
              name: <noninit>
            name: unity_FogColor
          fogMode: -1
          gpuProgramID: 115935
          m_Tags:
            tags:
              IGNOREPROJECTOR: true
              LIGHTMODE: FORWARDADD
              QUEUE: Geometry-99
              RenderType: Opaque
              SHADOWSUPPORT: true
          m_LOD: 0
          lighting: 0
        m_ProgramMask: 6
        progVertex:
          m_SubPrograms:
          - serializedVersion: 3
            m_BlobIndex: 48
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 49
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0200
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 50
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 51
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0400
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 52
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0500
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 53
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 06000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 54
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 060007000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 55
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 02000800
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 56
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 05000800
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 57
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000900
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 58
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010009000700
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 59
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 04000900
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 60
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 040009000700
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 61
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a000100
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 62
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 02000a00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 63
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 64
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a000400
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 65
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 05000a00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 66
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a0006000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 67
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a00060007000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 68
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 02000a000800
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 69
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 05000a000800
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 70
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a0001000900
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 71
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a00010009000700
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 72
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a0004000900
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 73
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a00040009000700
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 74
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 75
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 02000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 76
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 03000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 77
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 04000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 78
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 05000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 79
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 060003000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 80
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0600070003000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 384
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 81
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 020008000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 82
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 050008000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 336
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 83
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010009000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 84
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100090007000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 85
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 040009000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 86
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0400090007000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 87
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a0001000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 88
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 02000a000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 89
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a0003000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 90
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a0004000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 91
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 05000a000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 92
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a00060003000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 93
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a000600070003000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 384
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 94
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 02000a0008000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 95
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 05000a0008000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 336
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 96
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a00010009000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 97
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a000100090007000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 98
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a00040009000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 99
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0a000400090007000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
        progFragment:
          m_SubPrograms:
          - serializedVersion: 3
            m_BlobIndex: 100
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0100
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 101
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0200
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 240
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 102
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 103
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0400
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 104
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0500
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 105
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 06000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 4
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 1
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 106
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 060007000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 320
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 336
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 340
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 344
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 348
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 352
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 356
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 360
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 364
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 4
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 0
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 107
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 02000800
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 108
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 05000800
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 109
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 01000900
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 1
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 110
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 010009000700
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 0
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 111
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 04000900
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 1
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 112
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 040009000700
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 0
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 113
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a000100
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 114
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 02000a00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 240
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 115
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 116
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a000400
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 117
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 05000a00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 118
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a0006000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 4
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 1
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 119
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a00060007000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 320
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 336
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 340
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 344
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 348
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 352
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 356
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 360
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 364
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 4
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 0
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 120
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 02000a000800
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 121
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 05000a000800
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 122
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a0001000900
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 1
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 123
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a00010009000700
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 0
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 124
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a0004000900
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 1
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 125
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a00040009000700
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 304
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 0
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 126
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 01000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 127
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 02000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 128
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 03000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 129
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 04000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 130
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 05000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 131
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 060003000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 11
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 12
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 13
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 12
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 4
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 1
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 132
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0600070003000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 11
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 12
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 320
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 336
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 340
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 344
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 348
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 352
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 356
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 360
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 364
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 368
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 372
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 376
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 380
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 384
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 4
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 0
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 133
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 020008000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 260
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 264
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 268
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 272
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 134
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 050008000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 320
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 324
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 328
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 332
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 336
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 135
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 010009000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 11
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 12
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 1
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 136
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0100090007000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 11
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 0
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 137
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 040009000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 11
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 12
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 13
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 12
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 1
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 138
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0400090007000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 11
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 12
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 0
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 139
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a0001000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 140
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 02000a000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 141
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a0003000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 142
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a0004000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 143
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 05000a000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 144
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a00060003000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 11
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 12
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 13
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 12
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 4
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 1
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 145
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a000600070003000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 11
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 12
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 320
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 336
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 340
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 344
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 348
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 352
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 356
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 360
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 364
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 368
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 372
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 376
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 380
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 384
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 4
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 0
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 146
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 02000a0008000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 244
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 248
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 252
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 260
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 264
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 268
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 272
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 147
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 05000a0008000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 116
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 120
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 320
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 324
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 328
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 332
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 336
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 148
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a00010009000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 11
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 12
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 1
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 149
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a000100090007000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 11
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 0
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 150
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a00040009000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 11
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 12
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 13
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 12
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 1
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 151
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0a000400090007000b00
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 9
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 10
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 11
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 12
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 9
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 10
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 4
            - m_NameIndex: 0
              m_Index: 11
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 4
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 68
                m_ArraySize: 0
                m_Type: 1
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 72
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 76
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 240
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 256
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 276
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 280
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 284
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 288
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 292
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 296
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 300
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 304
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 308
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 312
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 316
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 320
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 64
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 3
              - m_NameIndex: 0
                m_Index: 80
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 96
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 144
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 32
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 384
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 400
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 416
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 16
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 32
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            - m_NameIndex: 0
              m_Index: 3
            - m_NameIndex: 0
              m_Index: 4
            - m_NameIndex: 0
              m_Index: 5
            m_UAVParams: []
            m_Samplers:
            - sampler: 85
              bindPoint: 0
            m_ShaderRequirements: 0
        progGeometry:
          m_SubPrograms: []
        progHull:
          m_SubPrograms: []
        progDomain:
          m_SubPrograms: []
        progRayTracing:
          m_SubPrograms: []
        m_HasInstancingVariant: 0
        m_HasProceduralInstancingVariant: 0
        m_UseName: 
        m_Name: 
        m_TextureName: 
        m_Tags:
          tags: {}
      - m_NameIndices:
          : 0
          LIGHTPROBE_SH: 1
          UNITY_HDR_ON: 2
          _NORMALMAP: 3
        m_Type: 0
        m_State:
          serializedVersion: 2
          m_Name: DEFERRED
          rtBlend0:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 1
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 1
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend1:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend2:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend3:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend4:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend5:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend6:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtBlend7:
            srcBlend:
              val: 1
              name: <noninit>
            destBlend:
              val: 0
              name: <noninit>
            srcBlendAlpha:
              val: 1
              name: <noninit>
            destBlendAlpha:
              val: 0
              name: <noninit>
            blendOp:
              val: 0
              name: <noninit>
            blendOpAlpha:
              val: 0
              name: <noninit>
            colMask:
              val: 15
              name: <noninit>
          rtSeparateBlend: 0
          zClip:
            val: 1
            name: <noninit>
          zTest:
            val: 4
            name: <noninit>
          zWrite:
            val: 0
            name: <noninit>
          culling:
            val: 2
            name: <noninit>
          offsetFactor:
            val: 0
            name: <noninit>
          offsetUnits:
            val: 0
            name: <noninit>
          alphaToMask:
            val: 0
            name: <noninit>
          stencilOp:
            pass:
              val: 0
              name: <noninit>
            fail:
              val: 0
              name: <noninit>
            zFail:
              val: 0
              name: <noninit>
            comp:
              val: 0
              name: <noninit>
          stencilOpFront:
            pass:
              val: 0
              name: <noninit>
            fail:
              val: 0
              name: <noninit>
            zFail:
              val: 0
              name: <noninit>
            comp:
              val: 8
              name: <noninit>
          stencilOpBack:
            pass:
              val: 0
              name: <noninit>
            fail:
              val: 0
              name: <noninit>
            zFail:
              val: 0
              name: <noninit>
            comp:
              val: 8
              name: <noninit>
          stencilReadMask:
            val: 255
            name: <noninit>
          stencilWriteMask:
            val: 255
            name: <noninit>
          stencilRef:
            val: 0
            name: <noninit>
          fogStart:
            val: 0
            name: unity_FogStart
          fogEnd:
            val: 0
            name: unity_FogEnd
          fogDensity:
            val: 0
            name: unity_FogDensity
          fogColor:
            x:
              val: 0
              name: <noninit>
            y:
              val: 0
              name: <noninit>
            z:
              val: 0
              name: <noninit>
            w:
              val: 0
              name: <noninit>
            name: unity_FogColor
          fogMode: -1
          gpuProgramID: 189444
          m_Tags:
            tags:
              IGNOREPROJECTOR: true
              LIGHTMODE: DEFERRED
              QUEUE: Geometry-99
              RenderType: Opaque
          m_LOD: 0
          lighting: 0
        m_ProgramMask: 6
        progVertex:
          m_SubPrograms:
          - serializedVersion: 3
            m_BlobIndex: 152
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 153
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0100
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 154
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0200
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 155
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000200
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 156
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 0300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 157
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 01000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 158
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 02000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 159
            m_Channels:
              m_Channels:
              - source: 0
                target: 0
              - source: 1
                target: 3
              - source: 5
                target: 6
              m_SourceMap: 255
            m_GlobalKeywordIndices: 010002000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 15
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams: []
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 672
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 688
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 704
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 720
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 0
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 176
            - m_NameIndex: 0
              m_MatrixParams:
              - m_NameIndex: 0
                m_Index: 272
                m_ArraySize: 0
                m_Type: 0
                m_RowCount: 4
              m_VectorParams: []
              m_StructParams: []
              m_Size: 368
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            - m_NameIndex: 0
              m_Index: 2
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
        progFragment:
          m_SubPrograms:
          - serializedVersion: 3
            m_BlobIndex: 160
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 196
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 200
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 204
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 240
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 161
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0100
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 196
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 200
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 204
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 240
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 624
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 640
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 656
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 162
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0200
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 196
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 200
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 204
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 240
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 163
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 01000200
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 196
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 200
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 204
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 240
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 624
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 640
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 656
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 164
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 0300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 196
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 200
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 204
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 165
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 01000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 196
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 200
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 204
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 624
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 640
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 656
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 166
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 02000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 196
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 200
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 204
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
          - serializedVersion: 3
            m_BlobIndex: 167
            m_Channels:
              m_Channels: []
              m_SourceMap: 0
            m_GlobalKeywordIndices: 010002000300
            m_LocalKeywordIndices: 
            m_ShaderHardwareTier: 3
            m_GpuProgramType: 17
            m_VectorParams: []
            m_MatrixParams: []
            m_TextureParams:
            - m_NameIndex: 0
              m_Index: 0
              m_SamplerIndex: 0
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 1
              m_SamplerIndex: 1
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 2
              m_SamplerIndex: 2
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 3
              m_SamplerIndex: 3
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 4
              m_SamplerIndex: 4
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 5
              m_SamplerIndex: 5
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 6
              m_SamplerIndex: 6
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 7
              m_SamplerIndex: 7
              m_MultiSampled: 0
              m_Dim: 2
            - m_NameIndex: 0
              m_Index: 8
              m_SamplerIndex: 8
              m_MultiSampled: 0
              m_Dim: 2
            m_BufferParams: []
            m_ConstantBuffers:
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 112
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 128
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 144
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 160
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 176
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 192
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 196
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 200
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 204
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 208
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 212
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 216
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 220
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 224
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 228
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 232
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              - m_NameIndex: 0
                m_Index: 236
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 1
              m_StructParams: []
              m_Size: 256
            - m_NameIndex: 0
              m_MatrixParams: []
              m_VectorParams:
              - m_NameIndex: 0
                m_Index: 624
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 640
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              - m_NameIndex: 0
                m_Index: 656
                m_ArraySize: 0
                m_Type: 0
                m_Dim: 4
              m_StructParams: []
              m_Size: 768
            m_ConstantBufferBindings:
            - m_NameIndex: 0
              m_Index: 0
            - m_NameIndex: 0
              m_Index: 1
            m_UAVParams: []
            m_Samplers: []
            m_ShaderRequirements: 0
        progGeometry:
          m_SubPrograms: []
        progHull:
          m_SubPrograms: []
        progDomain:
          m_SubPrograms: []
        progRayTracing:
          m_SubPrograms: []
        m_HasInstancingVariant: 0
        m_HasProceduralInstancingVariant: 0
        m_UseName: 
        m_Name: 
        m_TextureName: 
        m_Tags:
          tags: {}
      m_Tags:
        tags:
          IGNOREPROJECTOR: true
          QUEUE: Geometry-99
          RenderType: Opaque
      m_LOD: 0
    m_Name: Hidden/TerrainEngine/Splatmap/Standard-AddPass
    m_CustomEditorName: 
    m_FallbackName: Hidden/TerrainEngine/Splatmap/Diffuse-AddPass
    m_Dependencies: []
    m_DisableNoSubshadersMessage: 0
  platforms: 
  offsets: []
  compressedLengths: []
  decompressedLengths: []
  compressedBlob: 
  m_Dependencies:
  - {fileID: 10503, guid: 0000000000000000f000000000000000, type: 0}
  m_NonModifiableTextures: {}
  m_ShaderIsBaked: 0
  m_DefaultTextures: {}
  m_CompileInfo:
    m_Snippets:
      59176:
        serializedVersion: 3
        m_Code: "#line 42 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n\n//
          compile directives\n#pragma vertex vert_surf\n#pragma fragment frag_surf\n#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n#pragma multi_compile_fog\n#pragma target 3.0\n#pragma multi_compile_local
          __ _ALPHATEST_ON\n#pragma multi_compile_local __ _NORMALMAP\n#pragma multi_compile_instancing\n#pragma
          multi_compile_fwdbase\n#include \"HLSLSupport.cginc\"\n#define UNITY_ASSUME_UNIFORM_SCALING\n#define
          UNITY_DONT_INSTANCE_OBJECT_MATRICES\n#define UNITY_INSTANCED_LOD_FADE\n#include
          \"UnityShaderVariables.cginc\"\n#include \"UnityShaderUtilities.cginc\"\n//
          -------- variant for: <when no other keywords are defined>\n#if !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD3; // SH\n  #endif\n 
          UNITY_LIGHTING_COORDS(4,5)\n  #if SHADER_TARGET >= 30\n  float4 lmap :
          TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD3; // SH\n  #endif\n 
          UNITY_SHADOW_COORDS(4)\n  #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD5;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n//
          with lightmaps:\n#ifdef LIGHTMAP_ON\n// half-precision fragment shader
          registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float4 lmap : TEXCOORD3;\n  UNITY_LIGHTING_COORDS(4,5)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float4 lmap : TEXCOORD3;\n  UNITY_SHADOW_COORDS(4)\n  #ifdef DIRLIGHTMAP_COMBINED\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: _NORMALMAP \n#if defined(_NORMALMAP) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD4;
          // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n  #if SHADER_TARGET >= 30\n 
          float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD4;
          // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if SHADER_TARGET >= 30\n 
          float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float4 lmap : TEXCOORD4;\n  UNITY_LIGHTING_COORDS(5,6)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float4 lmap : TEXCOORD4;\n  UNITY_SHADOW_COORDS(5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n  #ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n 
          #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy
          + unity_LightmapST.zw;\n  #endif\n\n  // SH/ambient and vertex lights\n 
          #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      // Approximated illumination from non-important point
          lights\n      #ifdef VERTEXLIGHT_ON\n        o.sh += Shade4PointLights
          (\n          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\n         
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb,
          unity_LightColor[3].rgb,\n          unity_4LightAtten0, worldPos, worldNormal);\n     
          #endif\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n 
          #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: _ALPHATEST_ON \n#if defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD3; // SH\n  #endif\n 
          UNITY_LIGHTING_COORDS(4,5)\n  #if SHADER_TARGET >= 30\n  float4 lmap :
          TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD3; // SH\n  #endif\n 
          UNITY_SHADOW_COORDS(4)\n  #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD5;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n//
          with lightmaps:\n#ifdef LIGHTMAP_ON\n// half-precision fragment shader
          registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float4 lmap : TEXCOORD3;\n  UNITY_LIGHTING_COORDS(4,5)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float4 lmap : TEXCOORD3;\n  UNITY_SHADOW_COORDS(4)\n  #ifdef DIRLIGHTMAP_COMBINED\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: _ALPHATEST_ON _NORMALMAP \n#if defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD4;
          // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n  #if SHADER_TARGET >= 30\n 
          float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD4;
          // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if SHADER_TARGET >= 30\n 
          float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float4 lmap : TEXCOORD4;\n  UNITY_LIGHTING_COORDS(5,6)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float4 lmap : TEXCOORD4;\n  UNITY_SHADOW_COORDS(5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n  #ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n 
          #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy
          + unity_LightmapST.zw;\n  #endif\n\n  // SH/ambient and vertex lights\n 
          #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      // Approximated illumination from non-important point
          lights\n      #ifdef VERTEXLIGHT_ON\n        o.sh += Shade4PointLights
          (\n          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\n         
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb,
          unity_LightColor[3].rgb,\n          unity_4LightAtten0, worldPos, worldNormal);\n     
          #endif\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n 
          #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: INSTANCING_ON \n#if defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD3; // SH\n  #endif\n 
          UNITY_LIGHTING_COORDS(4,5)\n  #if SHADER_TARGET >= 30\n  float4 lmap :
          TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD3; // SH\n  #endif\n 
          UNITY_SHADOW_COORDS(4)\n  #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD5;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n//
          with lightmaps:\n#ifdef LIGHTMAP_ON\n// half-precision fragment shader
          registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float4 lmap : TEXCOORD3;\n  UNITY_LIGHTING_COORDS(4,5)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float4 lmap : TEXCOORD3;\n  UNITY_SHADOW_COORDS(4)\n  #ifdef DIRLIGHTMAP_COMBINED\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: INSTANCING_ON _NORMALMAP \n#if defined(INSTANCING_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD4;
          // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n  #if SHADER_TARGET >= 30\n 
          float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD4;
          // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if SHADER_TARGET >= 30\n 
          float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float4 lmap : TEXCOORD4;\n  UNITY_LIGHTING_COORDS(5,6)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float4 lmap : TEXCOORD4;\n  UNITY_SHADOW_COORDS(5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n  #ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n 
          #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy
          + unity_LightmapST.zw;\n  #endif\n\n  // SH/ambient and vertex lights\n 
          #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      // Approximated illumination from non-important point
          lights\n      #ifdef VERTEXLIGHT_ON\n        o.sh += Shade4PointLights
          (\n          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\n         
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb,
          unity_LightColor[3].rgb,\n          unity_4LightAtten0, worldPos, worldNormal);\n     
          #endif\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n 
          #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: INSTANCING_ON _ALPHATEST_ON \n#if defined(INSTANCING_ON) &&
          defined(_ALPHATEST_ON) && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD3; // SH\n  #endif\n 
          UNITY_LIGHTING_COORDS(4,5)\n  #if SHADER_TARGET >= 30\n  float4 lmap :
          TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD3; // SH\n  #endif\n 
          UNITY_SHADOW_COORDS(4)\n  #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD5;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n//
          with lightmaps:\n#ifdef LIGHTMAP_ON\n// half-precision fragment shader
          registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float4 lmap : TEXCOORD3;\n  UNITY_LIGHTING_COORDS(4,5)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float4 lmap : TEXCOORD3;\n  UNITY_SHADOW_COORDS(4)\n  #ifdef DIRLIGHTMAP_COMBINED\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: INSTANCING_ON _ALPHATEST_ON _NORMALMAP \n#if defined(INSTANCING_ON)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_EXP2) && !defined(FOG_LINEAR)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          YES\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD4;
          // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n  #if SHADER_TARGET >= 30\n 
          float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD4;
          // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if SHADER_TARGET >= 30\n 
          float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float4 lmap : TEXCOORD4;\n  UNITY_LIGHTING_COORDS(5,6)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float4 lmap : TEXCOORD4;\n  UNITY_SHADOW_COORDS(5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n  #ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n 
          #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy
          + unity_LightmapST.zw;\n  #endif\n\n  // SH/ambient and vertex lights\n 
          #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      // Approximated illumination from non-important point
          lights\n      #ifdef VERTEXLIGHT_ON\n        o.sh += Shade4PointLights
          (\n          unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\n         
          unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb,
          unity_LightColor[3].rgb,\n          unity_4LightAtten0, worldPos, worldNormal);\n     
          #endif\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n 
          #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR \n#if defined(FOG_LINEAR) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR _NORMALMAP \n#if defined(FOG_LINEAR) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(INSTANCING_ON) &&
          !defined(_ALPHATEST_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(6,7)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD8;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_SHADOW_COORDS(6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_LIGHTING_COORDS(6,7)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_SHADOW_COORDS(6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n// vertex shader\nv2f_surf
          vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf
          o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR _ALPHATEST_ON \n#if defined(FOG_LINEAR) && defined(_ALPHATEST_ON)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(INSTANCING_ON) &&
          !defined(_NORMALMAP)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          no\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_LINEAR)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_EXP2) && !defined(INSTANCING_ON)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          YES\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(6,7)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD8;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_SHADOW_COORDS(6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_LIGHTING_COORDS(6,7)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_SHADOW_COORDS(6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n// vertex shader\nv2f_surf
          vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf
          o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR INSTANCING_ON \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(_ALPHATEST_ON) &&
          !defined(_NORMALMAP)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          no\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR INSTANCING_ON _NORMALMAP \n#if defined(FOG_LINEAR)
          && defined(INSTANCING_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_EXP2) && !defined(_ALPHATEST_ON)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          YES\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(6,7)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD8;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_SHADOW_COORDS(6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_LIGHTING_COORDS(6,7)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_SHADOW_COORDS(6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n// vertex shader\nv2f_surf
          vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf
          o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR INSTANCING_ON _ALPHATEST_ON \n#if defined(FOG_LINEAR)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(_NORMALMAP)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          no\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR INSTANCING_ON _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_LINEAR)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          YES\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(6,7)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD8;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_SHADOW_COORDS(6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_LIGHTING_COORDS(6,7)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_SHADOW_COORDS(6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n// vertex shader\nv2f_surf
          vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf
          o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP \n#if defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP _NORMALMAP \n#if defined(FOG_EXP) && defined(_NORMALMAP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(6,7)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD8;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_SHADOW_COORDS(6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_LIGHTING_COORDS(6,7)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_SHADOW_COORDS(6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n// vertex shader\nv2f_surf
          vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf
          o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP _ALPHATEST_ON \n#if defined(FOG_EXP) && defined(_ALPHATEST_ON)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_EXP) &&
          defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP2) &&
          !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: YES\n// writes to emission: no\n// writes to occlusion: no\n//
          needs world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(6,7)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD8;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_SHADOW_COORDS(6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_LIGHTING_COORDS(6,7)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_SHADOW_COORDS(6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n// vertex shader\nv2f_surf
          vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf
          o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP INSTANCING_ON \n#if defined(FOG_EXP) && defined(INSTANCING_ON)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP INSTANCING_ON _NORMALMAP \n#if defined(FOG_EXP) &&
          defined(INSTANCING_ON) && defined(_NORMALMAP) && !defined(FOG_EXP2) &&
          !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: YES\n// writes to emission: no\n// writes to occlusion: no\n//
          needs world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(6,7)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD8;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_SHADOW_COORDS(6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_LIGHTING_COORDS(6,7)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_SHADOW_COORDS(6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n// vertex shader\nv2f_surf
          vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf
          o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP INSTANCING_ON _ALPHATEST_ON \n#if defined(FOG_EXP)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP INSTANCING_ON _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_EXP)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          YES\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(6,7)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD8;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_SHADOW_COORDS(6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_LIGHTING_COORDS(6,7)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_SHADOW_COORDS(6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n// vertex shader\nv2f_surf
          vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf
          o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 \n#if defined(FOG_EXP2) && !defined(FOG_EXP) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 _NORMALMAP \n#if defined(FOG_EXP2) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(6,7)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD8;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_SHADOW_COORDS(6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_LIGHTING_COORDS(6,7)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_SHADOW_COORDS(6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n// vertex shader\nv2f_surf
          vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf
          o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 _ALPHATEST_ON \n#if defined(FOG_EXP2) && defined(_ALPHATEST_ON)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_EXP2)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: YES\n// writes to emission: no\n// writes to occlusion: no\n//
          needs world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(6,7)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD8;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_SHADOW_COORDS(6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_LIGHTING_COORDS(6,7)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_SHADOW_COORDS(6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n// vertex shader\nv2f_surf
          vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf
          o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 INSTANCING_ON \n#if defined(FOG_EXP2) && defined(INSTANCING_ON)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 INSTANCING_ON _NORMALMAP \n#if defined(FOG_EXP2)
          && defined(INSTANCING_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: YES\n// writes to emission: no\n// writes to occlusion: no\n//
          needs world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(6,7)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD8;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_SHADOW_COORDS(6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_LIGHTING_COORDS(6,7)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_SHADOW_COORDS(6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n// vertex shader\nv2f_surf
          vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf
          o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 INSTANCING_ON _ALPHATEST_ON \n#if defined(FOG_EXP2)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_LINEAR) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 INSTANCING_ON _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_EXP2)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          YES\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(6,7)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD8;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  #if
          UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD5; // SH\n  #endif\n  UNITY_SHADOW_COORDS(6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_LIGHTING_COORDS(6,7)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float4 tSpace0 : TEXCOORD0;\n  float4
          tSpace1 : TEXCOORD1;\n  float4 tSpace2 : TEXCOORD2;\n  float4 custompack0
          : TEXCOORD3; // tc\n  float custompack1 : TEXCOORD4; // fogCoord\n  float4
          lmap : TEXCOORD5;\n  UNITY_SHADOW_COORDS(6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n// vertex shader\nv2f_surf
          vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf
          o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n\n  // compute lighting & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0,
          o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n\n"
        m_AssetPath: Assets/DefaultResourcesExtra/TerrainShaders/Splats
        m_PlatformMask: 4294967295
        m_HardwareTierVariantsMask: 0
        m_StartLine: 44
        m_TypesMask: 3
        m_IncludesHash:
          serializedVersion: 2
          Hash: 3ee3b648a41f870b7ce2234ae20da796
        m_CodeHash:
          serializedVersion: 2
          Hash: 00000000000000000000000000000000
        m_FromOther: 1
        m_ForceSyncCompilation: 0
        m_Language: 0
        m_VariantsUserGlobal0:
        - - __
          - FOG_LINEAR
          - FOG_EXP
          - FOG_EXP2
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal1:
        - - __
          - FOG_LINEAR
          - FOG_EXP
          - FOG_EXP2
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal2: []
        m_VariantsUserGlobal3: []
        m_VariantsUserGlobal4: []
        m_VariantsUserGlobal5: []
        m_VariantsUserGlobal6: []
        m_VariantsUserLocal0:
        - - __
          - _ALPHATEST_ON
        - - __
          - _NORMALMAP
        m_VariantsUserLocal1:
        - - __
          - _ALPHATEST_ON
        - - __
          - _NORMALMAP
        m_VariantsUserLocal2: []
        m_VariantsUserLocal3: []
        m_VariantsUserLocal4: []
        m_VariantsUserLocal5: []
        m_VariantsUserLocal6: []
        m_VariantsBuiltin0:
        - - DIRECTIONAL
        - - DIRECTIONAL
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        m_VariantsBuiltin1:
        - - DIRECTIONAL
        - - DIRECTIONAL
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        m_VariantsBuiltin2: []
        m_VariantsBuiltin3: []
        m_VariantsBuiltin4: []
        m_VariantsBuiltin5: []
        m_VariantsBuiltin6: []
        m_BaseRequirements: 227
        m_KeywordTargetInfo:
        - keywordName: SHADOWS_SOFT
          requirements: 227
        - keywordName: DIRLIGHTMAP_COMBINED
          requirements: 227
        - keywordName: DIRLIGHTMAP_SEPARATE
          requirements: 227
        - keywordName: DYNAMICLIGHTMAP_ON
          requirements: 227
        - keywordName: SHADOWS_SCREEN
          requirements: 227
        - keywordName: INSTANCING_ON
          requirements: 2048
        - keywordName: PROCEDURAL_INSTANCING_ON
          requirements: 16384
        - keywordName: STEREO_MULTIVIEW_ON
          requirements: 4075
        - keywordName: STEREO_INSTANCING_ON
          requirements: 4075
        m_NonStrippedUserKeywords: _ALPHATEST_ON _NORMALMAP FOG_LINEAR FOG_EXP FOG_EXP2
          INSTANCING_ON
        m_BuiltinKeywords: DIRECTIONAL LIGHTPROBE_SH SHADOWS_SHADOWMASK DYNAMICLIGHTMAP_ON
          LIGHTMAP_ON LIGHTMAP_SHADOW_MIXING DIRLIGHTMAP_COMBINED SHADOWS_SCREEN
          VERTEXLIGHT_ON
      86853:
        serializedVersion: 3
        m_Code: "#line 267 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n\n//
          compile directives\n#pragma vertex vert_surf\n#pragma fragment frag_surf\n#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n#pragma multi_compile_fog\n#pragma target 3.0\n#pragma multi_compile_local
          __ _ALPHATEST_ON\n#pragma multi_compile_local __ _NORMALMAP\n#pragma multi_compile_instancing\n#pragma
          multi_compile_fwdadd_fullshadows\n#include \"HLSLSupport.cginc\"\n#define
          UNITY_ASSUME_UNIFORM_SCALING\n#define UNITY_DONT_INSTANCE_OBJECT_MATRICES\n#define
          UNITY_INSTANCED_LOD_FADE\n#include \"UnityShaderVariables.cginc\"\n#include
          \"UnityShaderUtilities.cginc\"\n// -------- variant for: <when no other
          keywords are defined>\n#if !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  UNITY_LIGHTING_COORDS(3,4)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: _NORMALMAP \n#if defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.tc
          = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef
          USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n 
          worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: _ALPHATEST_ON \n#if defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  UNITY_LIGHTING_COORDS(3,4)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: _ALPHATEST_ON _NORMALMAP
          \n#if defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.tc
          = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef
          USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n 
          worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: INSTANCING_ON \n#if defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  UNITY_LIGHTING_COORDS(3,4)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: INSTANCING_ON _NORMALMAP
          \n#if defined(INSTANCING_ON) && defined(_NORMALMAP) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.tc
          = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef
          USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n 
          worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: INSTANCING_ON _ALPHATEST_ON \n#if defined(INSTANCING_ON) &&
          defined(_ALPHATEST_ON) && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  UNITY_LIGHTING_COORDS(3,4)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: INSTANCING_ON _ALPHATEST_ON
          _NORMALMAP \n#if defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.tc
          = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef
          USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n 
          worldN.y = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2,
          o.Normal);\n  worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  //
          Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR \n#if defined(FOG_LINEAR) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR _NORMALMAP
          \n#if defined(FOG_LINEAR) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_EXP2) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  float custompack1 : TEXCOORD5; // fogCoord\n  UNITY_LIGHTING_COORDS(6,7)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4 c = 0;\n 
          float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y =
          dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // Setup lighting
          environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n 
          gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR _ALPHATEST_ON \n#if defined(FOG_LINEAR) && defined(_ALPHATEST_ON)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(INSTANCING_ON) &&
          !defined(_NORMALMAP)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          no\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR _ALPHATEST_ON
          _NORMALMAP \n#if defined(FOG_LINEAR) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  float custompack1 : TEXCOORD5; // fogCoord\n  UNITY_LIGHTING_COORDS(6,7)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4 c = 0;\n 
          float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y =
          dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // Setup lighting
          environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n 
          gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR INSTANCING_ON \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(_ALPHATEST_ON) &&
          !defined(_NORMALMAP)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          no\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR INSTANCING_ON
          _NORMALMAP \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  float custompack1 : TEXCOORD5; // fogCoord\n  UNITY_LIGHTING_COORDS(6,7)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4 c = 0;\n 
          float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y =
          dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // Setup lighting
          environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n 
          gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR INSTANCING_ON _ALPHATEST_ON \n#if defined(FOG_LINEAR)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(_NORMALMAP)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          no\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR INSTANCING_ON
          _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_EXP2)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          YES\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  float custompack1 : TEXCOORD5; // fogCoord\n  UNITY_LIGHTING_COORDS(6,7)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4 c = 0;\n 
          float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y =
          dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // Setup lighting
          environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n 
          gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP \n#if defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP _NORMALMAP
          \n#if defined(FOG_EXP) && defined(_NORMALMAP) && !defined(FOG_EXP2) &&
          !defined(FOG_LINEAR) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  float custompack1 : TEXCOORD5; // fogCoord\n  UNITY_LIGHTING_COORDS(6,7)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4 c = 0;\n 
          float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y =
          dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // Setup lighting
          environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n 
          gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP _ALPHATEST_ON \n#if defined(FOG_EXP) && defined(_ALPHATEST_ON)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP _ALPHATEST_ON
          _NORMALMAP \n#if defined(FOG_EXP) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  float custompack1 : TEXCOORD5; // fogCoord\n  UNITY_LIGHTING_COORDS(6,7)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4 c = 0;\n 
          float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y =
          dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // Setup lighting
          environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n 
          gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP INSTANCING_ON \n#if defined(FOG_EXP) && defined(INSTANCING_ON)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP INSTANCING_ON
          _NORMALMAP \n#if defined(FOG_EXP) && defined(INSTANCING_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  float custompack1 : TEXCOORD5; // fogCoord\n  UNITY_LIGHTING_COORDS(6,7)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4 c = 0;\n 
          float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y =
          dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // Setup lighting
          environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n 
          gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP INSTANCING_ON _ALPHATEST_ON \n#if defined(FOG_EXP)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP INSTANCING_ON
          _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_EXP) && defined(INSTANCING_ON)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  float custompack1 : TEXCOORD5; // fogCoord\n  UNITY_LIGHTING_COORDS(6,7)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4 c = 0;\n 
          float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y =
          dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // Setup lighting
          environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n 
          gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 \n#if defined(FOG_EXP2) && !defined(FOG_EXP) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 _NORMALMAP
          \n#if defined(FOG_EXP2) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_LINEAR) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  float custompack1 : TEXCOORD5; // fogCoord\n  UNITY_LIGHTING_COORDS(6,7)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4 c = 0;\n 
          float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y =
          dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // Setup lighting
          environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n 
          gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 _ALPHATEST_ON \n#if defined(FOG_EXP2) && defined(_ALPHATEST_ON)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 _ALPHATEST_ON
          _NORMALMAP \n#if defined(FOG_EXP2) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  float custompack1 : TEXCOORD5; // fogCoord\n  UNITY_LIGHTING_COORDS(6,7)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4 c = 0;\n 
          float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y =
          dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // Setup lighting
          environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n 
          gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 INSTANCING_ON \n#if defined(FOG_EXP2) && defined(INSTANCING_ON)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 INSTANCING_ON
          _NORMALMAP \n#if defined(FOG_EXP2) && defined(INSTANCING_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  float custompack1 : TEXCOORD5; // fogCoord\n  UNITY_LIGHTING_COORDS(6,7)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4 c = 0;\n 
          float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y =
          dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // Setup lighting
          environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n 
          gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 INSTANCING_ON _ALPHATEST_ON \n#if defined(FOG_EXP2)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_LINEAR) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 INSTANCING_ON
          _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_EXP2) && defined(INSTANCING_ON)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_LINEAR)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          YES\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA
          half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define
          WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))\n#define
          WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal),
          dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))\n\n//
          Original surface shader snippet:\n#line 6\n\n        //#pragma surface
          surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          tSpace0 : TEXCOORD0;\n  float3 tSpace1 : TEXCOORD1;\n  float3 tSpace2 :
          TEXCOORD2;\n  float3 worldPos : TEXCOORD3;\n  float4 custompack0 : TEXCOORD4;
          // tc\n  float custompack1 : TEXCOORD5; // fogCoord\n  UNITY_LIGHTING_COORDS(6,7)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float3(worldTangent.x, worldBinormal.x, worldNormal.x);\n  o.tSpace1
          = float3(worldTangent.y, worldBinormal.y, worldNormal.y);\n  o.tSpace2
          = float3(worldTangent.z, worldBinormal.z, worldNormal.z);\n  o.worldPos.xyz
          = worldPos;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow
          and, possibly, light cookie coordinates to pixel shader\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4 c = 0;\n 
          float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y =
          dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // Setup lighting
          environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n 
          gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  gi.light.color *= atten;\n 
          c += LightingLambert (o, gi);\n  c.a = 0.0;\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n\n"
        m_AssetPath: Assets/DefaultResourcesExtra/TerrainShaders/Splats
        m_PlatformMask: 4294967295
        m_HardwareTierVariantsMask: 0
        m_StartLine: 269
        m_TypesMask: 3
        m_IncludesHash:
          serializedVersion: 2
          Hash: 3ee3b648a41f870b7ce2234ae20da796
        m_CodeHash:
          serializedVersion: 2
          Hash: 00000000000000000000000000000000
        m_FromOther: 1
        m_ForceSyncCompilation: 0
        m_Language: 0
        m_VariantsUserGlobal0:
        - - __
          - FOG_LINEAR
          - FOG_EXP
          - FOG_EXP2
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal1:
        - - __
          - FOG_LINEAR
          - FOG_EXP
          - FOG_EXP2
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal2: []
        m_VariantsUserGlobal3: []
        m_VariantsUserGlobal4: []
        m_VariantsUserGlobal5: []
        m_VariantsUserGlobal6: []
        m_VariantsUserLocal0:
        - - __
          - _ALPHATEST_ON
        - - __
          - _NORMALMAP
        m_VariantsUserLocal1:
        - - __
          - _ALPHATEST_ON
        - - __
          - _NORMALMAP
        m_VariantsUserLocal2: []
        m_VariantsUserLocal3: []
        m_VariantsUserLocal4: []
        m_VariantsUserLocal5: []
        m_VariantsUserLocal6: []
        m_VariantsBuiltin0:
        - - POINT
        - - DIRECTIONAL
        - - SPOT
        - - POINT_COOKIE
        - - DIRECTIONAL_COOKIE
        - - POINT
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - SHADOWS_SHADOWMASK
        - - SPOT
          - SHADOWS_SHADOWMASK
        - - POINT_COOKIE
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SHADOWMASK
        - - POINT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
        - - SPOT
          - SHADOWS_DEPTH
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SHADOWMASK
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SCREEN
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
        - - POINT
          - SHADOWS_CUBE
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        m_VariantsBuiltin1:
        - - POINT
        - - DIRECTIONAL
        - - SPOT
        - - POINT_COOKIE
        - - DIRECTIONAL_COOKIE
        - - POINT
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - SHADOWS_SHADOWMASK
        - - SPOT
          - SHADOWS_SHADOWMASK
        - - POINT_COOKIE
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SHADOWMASK
        - - POINT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
        - - SPOT
          - SHADOWS_DEPTH
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SHADOWMASK
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SCREEN
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
        - - POINT
          - SHADOWS_CUBE
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        m_VariantsBuiltin2: []
        m_VariantsBuiltin3: []
        m_VariantsBuiltin4: []
        m_VariantsBuiltin5: []
        m_VariantsBuiltin6: []
        m_BaseRequirements: 227
        m_KeywordTargetInfo:
        - keywordName: SHADOWS_SOFT
          requirements: 227
        - keywordName: DIRLIGHTMAP_COMBINED
          requirements: 227
        - keywordName: DIRLIGHTMAP_SEPARATE
          requirements: 227
        - keywordName: DYNAMICLIGHTMAP_ON
          requirements: 227
        - keywordName: SHADOWS_SCREEN
          requirements: 227
        - keywordName: INSTANCING_ON
          requirements: 2048
        - keywordName: PROCEDURAL_INSTANCING_ON
          requirements: 16384
        - keywordName: STEREO_MULTIVIEW_ON
          requirements: 4075
        - keywordName: STEREO_INSTANCING_ON
          requirements: 4075
        m_NonStrippedUserKeywords: _ALPHATEST_ON _NORMALMAP FOG_LINEAR FOG_EXP FOG_EXP2
          INSTANCING_ON
        m_BuiltinKeywords: POINT DIRECTIONAL SPOT POINT_COOKIE DIRECTIONAL_COOKIE
          SHADOWS_SHADOWMASK LIGHTMAP_SHADOW_MIXING SHADOWS_DEPTH SHADOWS_SOFT SHADOWS_SCREEN
          SHADOWS_CUBE
      162392:
        serializedVersion: 3
        m_Code: "#line 151 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n\n//
          compile directives\n#pragma vertex vert_surf\n#pragma fragment frag_surf\n#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n#pragma multi_compile_fog\n#pragma target 3.0\n#pragma multi_compile_local
          __ _ALPHATEST_ON\n#pragma multi_compile_local __ _NORMALMAP\n#pragma multi_compile_instancing\n#pragma
          skip_variants FOG_LINEAR FOG_EXP FOG_EXP2\n\n#include \"HLSLSupport.cginc\"\n#define
          UNITY_ASSUME_UNIFORM_SCALING\n#define UNITY_DONT_INSTANCE_OBJECT_MATRICES\n#define
          UNITY_INSTANCED_LOD_FADE\n#include \"UnityShaderVariables.cginc\"\n#include
          \"UnityShaderUtilities.cginc\"\n// -------- variant for: <when no other
          keywords are defined>\n#if !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: _NORMALMAP \n#if defined(_NORMALMAP) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: _ALPHATEST_ON \n#if defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: _ALPHATEST_ON _NORMALMAP \n#if defined(_ALPHATEST_ON)
          && defined(_NORMALMAP) && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: INSTANCING_ON \n#if defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: INSTANCING_ON _NORMALMAP \n#if defined(INSTANCING_ON)
          && defined(_NORMALMAP) && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(_ALPHATEST_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: INSTANCING_ON _ALPHATEST_ON \n#if defined(INSTANCING_ON)
          && defined(_ALPHATEST_ON) && !defined(FOG_EXP) && !defined(FOG_EXP2) &&
          !defined(FOG_LINEAR) && !defined(_NORMALMAP)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          no\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: INSTANCING_ON _ALPHATEST_ON _NORMALMAP \n#if defined(INSTANCING_ON)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_EXP2) && !defined(FOG_LINEAR)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          YES\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_LINEAR \n#if defined(FOG_LINEAR) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_LINEAR _NORMALMAP \n#if defined(FOG_LINEAR) &&
          defined(_NORMALMAP) && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_LINEAR _ALPHATEST_ON \n#if defined(FOG_LINEAR)
          && defined(_ALPHATEST_ON) && !defined(FOG_EXP) && !defined(FOG_EXP2) &&
          !defined(INSTANCING_ON) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_LINEAR _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_LINEAR)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_EXP2) && !defined(INSTANCING_ON)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          YES\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_LINEAR INSTANCING_ON \n#if defined(FOG_LINEAR)
          && defined(INSTANCING_ON) && !defined(FOG_EXP) && !defined(FOG_EXP2) &&
          !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_LINEAR INSTANCING_ON _NORMALMAP \n#if defined(FOG_LINEAR)
          && defined(INSTANCING_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_EXP2) && !defined(_ALPHATEST_ON)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          YES\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_LINEAR INSTANCING_ON _ALPHATEST_ON \n#if defined(FOG_LINEAR)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(_NORMALMAP)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          no\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_LINEAR INSTANCING_ON _ALPHATEST_ON _NORMALMAP
          \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON) && defined(_ALPHATEST_ON)
          && defined(_NORMALMAP) && !defined(FOG_EXP) && !defined(FOG_EXP2)\n// Surface
          shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP \n#if defined(FOG_EXP) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP _NORMALMAP \n#if defined(FOG_EXP) && defined(_NORMALMAP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP _ALPHATEST_ON \n#if defined(FOG_EXP) && defined(_ALPHATEST_ON)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_EXP)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: YES\n// writes to emission: no\n// writes to occlusion: no\n//
          needs world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP INSTANCING_ON \n#if defined(FOG_EXP) && defined(INSTANCING_ON)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP INSTANCING_ON _NORMALMAP \n#if defined(FOG_EXP)
          && defined(INSTANCING_ON) && defined(_NORMALMAP) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: YES\n// writes to emission: no\n// writes to occlusion: no\n//
          needs world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP INSTANCING_ON _ALPHATEST_ON \n#if defined(FOG_EXP)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP INSTANCING_ON _ALPHATEST_ON _NORMALMAP \n#if
          defined(FOG_EXP) && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) &&
          defined(_NORMALMAP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)\n// Surface
          shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP2 \n#if defined(FOG_EXP2) && !defined(FOG_EXP)
          && !defined(FOG_LINEAR) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP2 _NORMALMAP \n#if defined(FOG_EXP2) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP2 _ALPHATEST_ON \n#if defined(FOG_EXP2) &&
          defined(_ALPHATEST_ON) && !defined(FOG_EXP) && !defined(FOG_LINEAR) &&
          !defined(INSTANCING_ON) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP2 _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_EXP2)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: YES\n// writes to emission: no\n// writes to occlusion: no\n//
          needs world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP2 INSTANCING_ON \n#if defined(FOG_EXP2) &&
          defined(INSTANCING_ON) && !defined(FOG_EXP) && !defined(FOG_LINEAR) &&
          !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP2 INSTANCING_ON _NORMALMAP \n#if defined(FOG_EXP2)
          && defined(INSTANCING_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: YES\n// writes to emission: no\n// writes to occlusion: no\n//
          needs world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP2 INSTANCING_ON _ALPHATEST_ON \n#if defined(FOG_EXP2)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_LINEAR) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP2 INSTANCING_ON _ALPHATEST_ON _NORMALMAP \n#if
          defined(FOG_EXP2) && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) &&
          defined(_NORMALMAP) && !defined(FOG_EXP) && !defined(FOG_LINEAR)\n// Surface
          shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n    UNITY_RECONSTRUCT_TBN(IN);\n 
          #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = float3(IN.tSpace0.w,
          IN.tSpace1.w, IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3
          lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\n  float3 worldN;\n  worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y
          = dot(_unity_tbn_1, o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n 
          worldN = normalize(worldN);\n  o.Normal = worldN;\n\n  // output normal
          and specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a
          = o.Specular;\n  SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n\n"
        m_AssetPath: Assets/DefaultResourcesExtra/TerrainShaders/Splats
        m_PlatformMask: 4294967295
        m_HardwareTierVariantsMask: 0
        m_StartLine: 153
        m_TypesMask: 3
        m_IncludesHash:
          serializedVersion: 2
          Hash: b2f21b964a0684e6b299d78f0232fab3
        m_CodeHash:
          serializedVersion: 2
          Hash: 00000000000000000000000000000000
        m_FromOther: 1
        m_ForceSyncCompilation: 0
        m_Language: 0
        m_VariantsUserGlobal0:
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal1:
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal2: []
        m_VariantsUserGlobal3: []
        m_VariantsUserGlobal4: []
        m_VariantsUserGlobal5: []
        m_VariantsUserGlobal6: []
        m_VariantsUserLocal0:
        - - __
          - _ALPHATEST_ON
        - - __
          - _NORMALMAP
        m_VariantsUserLocal1:
        - - __
          - _ALPHATEST_ON
        - - __
          - _NORMALMAP
        m_VariantsUserLocal2: []
        m_VariantsUserLocal3: []
        m_VariantsUserLocal4: []
        m_VariantsUserLocal5: []
        m_VariantsUserLocal6: []
        m_VariantsBuiltin0: []
        m_VariantsBuiltin1: []
        m_VariantsBuiltin2: []
        m_VariantsBuiltin3: []
        m_VariantsBuiltin4: []
        m_VariantsBuiltin5: []
        m_VariantsBuiltin6: []
        m_BaseRequirements: 227
        m_KeywordTargetInfo:
        - keywordName: SHADOWS_SOFT
          requirements: 227
        - keywordName: DIRLIGHTMAP_COMBINED
          requirements: 227
        - keywordName: DIRLIGHTMAP_SEPARATE
          requirements: 227
        - keywordName: DYNAMICLIGHTMAP_ON
          requirements: 227
        - keywordName: SHADOWS_SCREEN
          requirements: 227
        - keywordName: INSTANCING_ON
          requirements: 2048
        - keywordName: PROCEDURAL_INSTANCING_ON
          requirements: 16384
        - keywordName: STEREO_MULTIVIEW_ON
          requirements: 4075
        - keywordName: STEREO_INSTANCING_ON
          requirements: 4075
        m_NonStrippedUserKeywords: _ALPHATEST_ON _NORMALMAP FOG_LINEAR FOG_EXP FOG_EXP2
          INSTANCING_ON
        m_BuiltinKeywords: 
      225005:
        serializedVersion: 3
        m_Code: "#line 138 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n\n//
          compile directives\n#pragma vertex vert_surf\n#pragma fragment frag_surf\n#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n#pragma multi_compile_fog\n#pragma target 3.0\n#pragma multi_compile_local
          __ _ALPHATEST_ON\n#pragma multi_compile_local __ _NORMALMAP\n#pragma multi_compile_instancing\n#pragma
          multi_compile_prepassfinal\n#include \"HLSLSupport.cginc\"\n#define UNITY_ASSUME_UNIFORM_SCALING\n#define
          UNITY_DONT_INSTANCE_OBJECT_MATRICES\n#define UNITY_INSTANCED_LOD_FADE\n#include
          \"UnityShaderVariables.cginc\"\n#include \"UnityShaderUtilities.cginc\"\n//
          -------- variant for: <when no other keywords are defined>\n#if !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float4
          screen : TEXCOORD2;\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          float3 vlight : TEXCOORD4;\n#else\n#ifdef DIRLIGHTMAP_OFF\n  float4 lmapFadePos
          : TEXCOORD4;\n#endif\n#endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n\n 
          // call surface function\n  surf (surfIN, o);\n  half4 light = tex2Dproj
          (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if defined (SHADER_API_MOBILE)\n 
          light = max(light, half4(0.001, 0.001, 0.001, 0.001));\n#endif\n#ifndef
          UNITY_HDR_ON\n  light = -log2(light);\n#endif\n  #ifdef LIGHTMAP_ON\n   
          #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n      fixed4 lmtex =
          UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3 lm = DecodeLightmap
          (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: _NORMALMAP \n#if defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float4
          screen : TEXCOORD2;\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          float3 vlight : TEXCOORD4;\n#else\n#ifdef DIRLIGHTMAP_OFF\n  float4 lmapFadePos
          : TEXCOORD4;\n#endif\n#endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n\n 
          // call surface function\n  surf (surfIN, o);\n  half4 light = tex2Dproj
          (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if defined (SHADER_API_MOBILE)\n 
          light = max(light, half4(0.001, 0.001, 0.001, 0.001));\n#endif\n#ifndef
          UNITY_HDR_ON\n  light = -log2(light);\n#endif\n  #ifdef LIGHTMAP_ON\n   
          #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n      fixed4 lmtex =
          UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3 lm = DecodeLightmap
          (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: _ALPHATEST_ON \n#if defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float4
          screen : TEXCOORD2;\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          float3 vlight : TEXCOORD4;\n#else\n#ifdef DIRLIGHTMAP_OFF\n  float4 lmapFadePos
          : TEXCOORD4;\n#endif\n#endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n\n 
          // call surface function\n  surf (surfIN, o);\n  half4 light = tex2Dproj
          (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if defined (SHADER_API_MOBILE)\n 
          light = max(light, half4(0.001, 0.001, 0.001, 0.001));\n#endif\n#ifndef
          UNITY_HDR_ON\n  light = -log2(light);\n#endif\n  #ifdef LIGHTMAP_ON\n   
          #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n      fixed4 lmtex =
          UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3 lm = DecodeLightmap
          (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: _ALPHATEST_ON _NORMALMAP
          \n#if defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float4
          screen : TEXCOORD2;\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          float3 vlight : TEXCOORD4;\n#else\n#ifdef DIRLIGHTMAP_OFF\n  float4 lmapFadePos
          : TEXCOORD4;\n#endif\n#endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n\n 
          // call surface function\n  surf (surfIN, o);\n  half4 light = tex2Dproj
          (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if defined (SHADER_API_MOBILE)\n 
          light = max(light, half4(0.001, 0.001, 0.001, 0.001));\n#endif\n#ifndef
          UNITY_HDR_ON\n  light = -log2(light);\n#endif\n  #ifdef LIGHTMAP_ON\n   
          #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n      fixed4 lmtex =
          UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3 lm = DecodeLightmap
          (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: INSTANCING_ON \n#if defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float4
          screen : TEXCOORD2;\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          float3 vlight : TEXCOORD4;\n#else\n#ifdef DIRLIGHTMAP_OFF\n  float4 lmapFadePos
          : TEXCOORD4;\n#endif\n#endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n\n 
          // call surface function\n  surf (surfIN, o);\n  half4 light = tex2Dproj
          (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if defined (SHADER_API_MOBILE)\n 
          light = max(light, half4(0.001, 0.001, 0.001, 0.001));\n#endif\n#ifndef
          UNITY_HDR_ON\n  light = -log2(light);\n#endif\n  #ifdef LIGHTMAP_ON\n   
          #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n      fixed4 lmtex =
          UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3 lm = DecodeLightmap
          (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: INSTANCING_ON _NORMALMAP
          \n#if defined(INSTANCING_ON) && defined(_NORMALMAP) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float4
          screen : TEXCOORD2;\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          float3 vlight : TEXCOORD4;\n#else\n#ifdef DIRLIGHTMAP_OFF\n  float4 lmapFadePos
          : TEXCOORD4;\n#endif\n#endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n\n 
          // call surface function\n  surf (surfIN, o);\n  half4 light = tex2Dproj
          (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if defined (SHADER_API_MOBILE)\n 
          light = max(light, half4(0.001, 0.001, 0.001, 0.001));\n#endif\n#ifndef
          UNITY_HDR_ON\n  light = -log2(light);\n#endif\n  #ifdef LIGHTMAP_ON\n   
          #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n      fixed4 lmtex =
          UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3 lm = DecodeLightmap
          (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: INSTANCING_ON _ALPHATEST_ON \n#if defined(INSTANCING_ON) &&
          defined(_ALPHATEST_ON) && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float4
          screen : TEXCOORD2;\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          float3 vlight : TEXCOORD4;\n#else\n#ifdef DIRLIGHTMAP_OFF\n  float4 lmapFadePos
          : TEXCOORD4;\n#endif\n#endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n\n 
          // call surface function\n  surf (surfIN, o);\n  half4 light = tex2Dproj
          (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if defined (SHADER_API_MOBILE)\n 
          light = max(light, half4(0.001, 0.001, 0.001, 0.001));\n#endif\n#ifndef
          UNITY_HDR_ON\n  light = -log2(light);\n#endif\n  #ifdef LIGHTMAP_ON\n   
          #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n      fixed4 lmtex =
          UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3 lm = DecodeLightmap
          (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: INSTANCING_ON _ALPHATEST_ON
          _NORMALMAP \n#if defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float4
          screen : TEXCOORD2;\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          float3 vlight : TEXCOORD4;\n#else\n#ifdef DIRLIGHTMAP_OFF\n  float4 lmapFadePos
          : TEXCOORD4;\n#endif\n#endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n\n 
          // call surface function\n  surf (surfIN, o);\n  half4 light = tex2Dproj
          (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if defined (SHADER_API_MOBILE)\n 
          light = max(light, half4(0.001, 0.001, 0.001, 0.001));\n#endif\n#ifndef
          UNITY_HDR_ON\n  light = -log2(light);\n#endif\n  #ifdef LIGHTMAP_ON\n   
          #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n      fixed4 lmtex =
          UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3 lm = DecodeLightmap
          (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR \n#if defined(FOG_LINEAR) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR _NORMALMAP
          \n#if defined(FOG_LINEAR) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_EXP2) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR _ALPHATEST_ON \n#if defined(FOG_LINEAR) && defined(_ALPHATEST_ON)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(INSTANCING_ON) &&
          !defined(_NORMALMAP)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          no\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR _ALPHATEST_ON
          _NORMALMAP \n#if defined(FOG_LINEAR) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR INSTANCING_ON \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(_ALPHATEST_ON) &&
          !defined(_NORMALMAP)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          no\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR INSTANCING_ON
          _NORMALMAP \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR INSTANCING_ON _ALPHATEST_ON \n#if defined(FOG_LINEAR)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(_NORMALMAP)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          no\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR INSTANCING_ON
          _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_EXP2)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          YES\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP \n#if defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP _NORMALMAP
          \n#if defined(FOG_EXP) && defined(_NORMALMAP) && !defined(FOG_EXP2) &&
          !defined(FOG_LINEAR) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP _ALPHATEST_ON \n#if defined(FOG_EXP) && defined(_ALPHATEST_ON)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP _ALPHATEST_ON
          _NORMALMAP \n#if defined(FOG_EXP) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP INSTANCING_ON \n#if defined(FOG_EXP) && defined(INSTANCING_ON)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP INSTANCING_ON
          _NORMALMAP \n#if defined(FOG_EXP) && defined(INSTANCING_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP INSTANCING_ON _ALPHATEST_ON \n#if defined(FOG_EXP)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP INSTANCING_ON
          _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_EXP) && defined(INSTANCING_ON)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 \n#if defined(FOG_EXP2) && !defined(FOG_EXP) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 _NORMALMAP
          \n#if defined(FOG_EXP2) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_LINEAR) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 _ALPHATEST_ON \n#if defined(FOG_EXP2) && defined(_ALPHATEST_ON)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 _ALPHATEST_ON
          _NORMALMAP \n#if defined(FOG_EXP2) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 INSTANCING_ON \n#if defined(FOG_EXP2) && defined(INSTANCING_ON)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)
          && !defined(_NORMALMAP)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 INSTANCING_ON
          _NORMALMAP \n#if defined(FOG_EXP2) && defined(INSTANCING_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 INSTANCING_ON _ALPHATEST_ON \n#if defined(FOG_EXP2)
          && defined(INSTANCING_ON) && defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_LINEAR) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 INSTANCING_ON
          _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_EXP2) && defined(INSTANCING_ON)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_LINEAR)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          YES\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      fixed4 lmIndTex = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd,
          unity_Lightmap, IN.lmap.xy);\n      half4 lm = half4(DecodeDirectionalLightmap
          (DecodeLightmap(lmtex), lmIndTex, o.Normal), 0);\n      light += lm;\n   
          #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb += IN.vlight;\n  #endif
          // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4 dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap,
          IN.lmap.zw);\n  light.rgb += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n 
          fixed4 c = LightingLambert_PrePass (o, light);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n\n"
        m_AssetPath: Assets/DefaultResourcesExtra/TerrainShaders/Splats
        m_PlatformMask: 4294967295
        m_HardwareTierVariantsMask: 0
        m_StartLine: 140
        m_TypesMask: 3
        m_IncludesHash:
          serializedVersion: 2
          Hash: b2f21b964a0684e6b299d78f0232fab3
        m_CodeHash:
          serializedVersion: 2
          Hash: 00000000000000000000000000000000
        m_FromOther: 1
        m_ForceSyncCompilation: 0
        m_Language: 0
        m_VariantsUserGlobal0:
        - - __
          - FOG_LINEAR
          - FOG_EXP
          - FOG_EXP2
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal1:
        - - __
          - FOG_LINEAR
          - FOG_EXP
          - FOG_EXP2
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal2: []
        m_VariantsUserGlobal3: []
        m_VariantsUserGlobal4: []
        m_VariantsUserGlobal5: []
        m_VariantsUserGlobal6: []
        m_VariantsUserLocal0:
        - - __
          - _ALPHATEST_ON
        - - __
          - _NORMALMAP
        m_VariantsUserLocal1:
        - - __
          - _ALPHATEST_ON
        - - __
          - _NORMALMAP
        m_VariantsUserLocal2: []
        m_VariantsUserLocal3: []
        m_VariantsUserLocal4: []
        m_VariantsUserLocal5: []
        m_VariantsUserLocal6: []
        m_VariantsBuiltin0:
        - []
        - - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
        - - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
        - - LIGHTMAP_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        m_VariantsBuiltin1:
        - []
        - - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
        - - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
        - - LIGHTMAP_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        m_VariantsBuiltin2: []
        m_VariantsBuiltin3: []
        m_VariantsBuiltin4: []
        m_VariantsBuiltin5: []
        m_VariantsBuiltin6: []
        m_BaseRequirements: 227
        m_KeywordTargetInfo:
        - keywordName: SHADOWS_SOFT
          requirements: 227
        - keywordName: DIRLIGHTMAP_COMBINED
          requirements: 227
        - keywordName: DIRLIGHTMAP_SEPARATE
          requirements: 227
        - keywordName: DYNAMICLIGHTMAP_ON
          requirements: 227
        - keywordName: SHADOWS_SCREEN
          requirements: 227
        - keywordName: INSTANCING_ON
          requirements: 2048
        - keywordName: PROCEDURAL_INSTANCING_ON
          requirements: 16384
        - keywordName: STEREO_MULTIVIEW_ON
          requirements: 4075
        - keywordName: STEREO_INSTANCING_ON
          requirements: 4075
        m_NonStrippedUserKeywords: _ALPHATEST_ON _NORMALMAP FOG_LINEAR FOG_EXP FOG_EXP2
          INSTANCING_ON
        m_BuiltinKeywords: LIGHTPROBE_SH DYNAMICLIGHTMAP_ON SHADOWS_SHADOWMASK LIGHTMAP_ON
          DIRLIGHTMAP_COMBINED UNITY_HDR_ON
      287015:
        serializedVersion: 3
        m_Code: "#line 195 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n\n//
          compile directives\n#pragma vertex vert_surf\n#pragma fragment frag_surf\n#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n#pragma multi_compile_fog\n#pragma target 3.0\n#pragma multi_compile_local
          __ _ALPHATEST_ON\n#pragma multi_compile_local __ _NORMALMAP\n#pragma multi_compile_instancing\n#pragma
          exclude_renderers nomrt\n#pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2\n#pragma
          multi_compile_prepassfinal\n#include \"HLSLSupport.cginc\"\n#define UNITY_ASSUME_UNIFORM_SCALING\n#define
          UNITY_DONT_INSTANCE_OBJECT_MATRICES\n#define UNITY_INSTANCED_LOD_FADE\n#include
          \"UnityShaderVariables.cginc\"\n#include \"UnityShaderUtilities.cginc\"\n//
          -------- variant for: <when no other keywords are defined>\n#if !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD4; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD4;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: _NORMALMAP \n#if
          defined(_NORMALMAP) && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)\n// Surface shader
          code generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes
          to per-pixel normal: YES\n// writes to emission: no\n// writes to occlusion:
          no\n// needs world space reflection vector: no\n// needs world space normal
          vector: no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float4 lmap : TEXCOORD4;\n#ifndef
          LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n   
          float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.tc
          = IN.custompack0.xyzw;\n  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w,
          IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n  worldN.x =
          dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n 
          worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: _ALPHATEST_ON
          \n#if defined(_ALPHATEST_ON) && !defined(FOG_EXP) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR) && !defined(INSTANCING_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD4; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD4;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: _ALPHATEST_ON
          _NORMALMAP \n#if defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float4 lmap : TEXCOORD4;\n#ifndef
          LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n   
          float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.tc
          = IN.custompack0.xyzw;\n  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w,
          IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n  worldN.x =
          dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n 
          worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: INSTANCING_ON
          \n#if defined(INSTANCING_ON) && !defined(FOG_EXP) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD4; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD4;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: INSTANCING_ON
          _NORMALMAP \n#if defined(INSTANCING_ON) && defined(_NORMALMAP) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float4 lmap : TEXCOORD4;\n#ifndef
          LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n   
          float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.tc
          = IN.custompack0.xyzw;\n  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w,
          IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n  worldN.x =
          dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n 
          worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: INSTANCING_ON
          _ALPHATEST_ON \n#if defined(INSTANCING_ON) && defined(_ALPHATEST_ON) &&
          !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD4; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD4;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: INSTANCING_ON
          _ALPHATEST_ON _NORMALMAP \n#if defined(INSTANCING_ON) && defined(_ALPHATEST_ON)
          && defined(_NORMALMAP) && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float4 lmap : TEXCOORD4;\n#ifndef
          LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n   
          float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n 
          fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3
          worldBinormal = cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.tc
          = IN.custompack0.xyzw;\n  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w,
          IN.tSpace2.w);\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN,
          o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n  worldN.x =
          dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1, o.Normal);\n 
          worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR \n#if
          defined(FOG_LINEAR) && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR _NORMALMAP
          \n#if defined(FOG_LINEAR) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_EXP2) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  float4 lmap : TEXCOORD5;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD6; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD6;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n 
          worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1,
          o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR _ALPHATEST_ON
          \n#if defined(FOG_LINEAR) && defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(INSTANCING_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR _ALPHATEST_ON
          _NORMALMAP \n#if defined(FOG_LINEAR) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  float4 lmap : TEXCOORD5;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD6; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD6;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n 
          worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1,
          o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR INSTANCING_ON
          \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR INSTANCING_ON
          _NORMALMAP \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  float4 lmap : TEXCOORD5;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD6; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD6;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n 
          worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1,
          o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR INSTANCING_ON
          _ALPHATEST_ON \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON) && defined(_ALPHATEST_ON)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR INSTANCING_ON
          _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_EXP2)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          YES\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  float4 lmap : TEXCOORD5;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD6; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD6;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n 
          worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1,
          o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP \n#if
          defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP _NORMALMAP
          \n#if defined(FOG_EXP) && defined(_NORMALMAP) && !defined(FOG_EXP2) &&
          !defined(FOG_LINEAR) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  float4 lmap : TEXCOORD5;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD6; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD6;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n 
          worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1,
          o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP _ALPHATEST_ON
          \n#if defined(FOG_EXP) && defined(_ALPHATEST_ON) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR) && !defined(INSTANCING_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP _ALPHATEST_ON
          _NORMALMAP \n#if defined(FOG_EXP) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  float4 lmap : TEXCOORD5;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD6; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD6;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n 
          worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1,
          o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP INSTANCING_ON
          \n#if defined(FOG_EXP) && defined(INSTANCING_ON) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP INSTANCING_ON
          _NORMALMAP \n#if defined(FOG_EXP) && defined(INSTANCING_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  float4 lmap : TEXCOORD5;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD6; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD6;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n 
          worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1,
          o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP INSTANCING_ON
          _ALPHATEST_ON \n#if defined(FOG_EXP) && defined(INSTANCING_ON) && defined(_ALPHATEST_ON)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP INSTANCING_ON
          _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_EXP) && defined(INSTANCING_ON)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: YES\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3
          internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal) reflect
          (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  float4 lmap : TEXCOORD5;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD6; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD6;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n 
          worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1,
          o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 \n#if
          defined(FOG_EXP2) && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)
          && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 _NORMALMAP
          \n#if defined(FOG_EXP2) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_LINEAR) && !defined(INSTANCING_ON) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  float4 lmap : TEXCOORD5;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD6; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD6;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n 
          worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1,
          o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 _ALPHATEST_ON
          \n#if defined(FOG_EXP2) && defined(_ALPHATEST_ON) && !defined(FOG_EXP)
          && !defined(FOG_LINEAR) && !defined(INSTANCING_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 _ALPHATEST_ON
          _NORMALMAP \n#if defined(FOG_EXP2) && defined(_ALPHATEST_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  float4 lmap : TEXCOORD5;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD6; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD6;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n 
          worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1,
          o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 INSTANCING_ON
          \n#if defined(FOG_EXP2) && defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 INSTANCING_ON
          _NORMALMAP \n#if defined(FOG_EXP2) && defined(INSTANCING_ON) && defined(_NORMALMAP)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(_ALPHATEST_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: YES\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: YES\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  float4 lmap : TEXCOORD5;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD6; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD6;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n 
          worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1,
          o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 INSTANCING_ON
          _ALPHATEST_ON \n#if defined(FOG_EXP2) && defined(INSTANCING_ON) && defined(_ALPHATEST_ON)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(_NORMALMAP)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 INSTANCING_ON
          _ALPHATEST_ON _NORMALMAP \n#if defined(FOG_EXP2) && defined(INSTANCING_ON)
          && defined(_ALPHATEST_ON) && defined(_NORMALMAP) && !defined(FOG_EXP) &&
          !defined(FOG_LINEAR)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: YES\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          YES\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA half3 internalSurfaceTtoW0;
          half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;\n#define WorldReflectionVector(data,normal)
          reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal)))\n#define WorldNormalVector(data,normal)
          fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal),
          dot(data.internalSurfaceTtoW2,normal))\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 31 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n                //#pragma target 3.0\n               
          //#pragma multi_compile_local __ _ALPHATEST_ON\n                //#pragma
          multi_compile_local __ _NORMALMAP\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float4
          tSpace0 : TEXCOORD0;\n  float4 tSpace1 : TEXCOORD1;\n  float4 tSpace2 :
          TEXCOORD2;\n  float4 custompack0 : TEXCOORD3; // tc\n  float custompack1
          : TEXCOORD4; // fogCoord\n  float4 lmap : TEXCOORD5;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD6; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD6;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  o.tSpace0 = float4(worldTangent.x,
          worldBinormal.x, worldNormal.x, worldPos.x);\n  o.tSpace1 = float4(worldTangent.y,
          worldBinormal.y, worldNormal.y, worldPos.y);\n  o.tSpace2 = float4(worldTangent.z,
          worldBinormal.z, worldNormal.z, worldPos.z);\n#ifdef DYNAMICLIGHTMAP_ON\n 
          o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  #ifdef FOG_COMBINED_WITH_TSPACE\n   
          UNITY_RECONSTRUCT_TBN(IN);\n  #else\n    UNITY_EXTRACT_TBN(IN);\n  #endif\n 
          UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x
          = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord = IN.custompack1.x;\n 
          float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = fixed3(0,0,1);\n\n  // call surface function\n 
          surf (surfIN, o);\nfixed3 originalNormal = o.Normal;\n  float3 worldN;\n 
          worldN.x = dot(_unity_tbn_0, o.Normal);\n  worldN.y = dot(_unity_tbn_1,
          o.Normal);\n  worldN.z = dot(_unity_tbn_2, o.Normal);\n  worldN = normalize(worldN);\n 
          o.Normal = worldN;\n  half atten = 1;\n\n  // Setup lighting environment\n 
          UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse
          = 0;\n  gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir
          = half3(0,1,0);\n  // Call GI (lightmaps/SH/reflections) lighting function\n 
          UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n 
          giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten
          = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // call lighting function to output
          g-buffer\n  outEmission = LightingLambert_Deferred (o, gi, outGBuffer0,
          outGBuffer1, outGBuffer2);\n  #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT
          > 4)\n    outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n 
          #endif\n  #ifndef UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n 
          #endif\n  SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n\n"
        m_AssetPath: Assets/DefaultResourcesExtra/TerrainShaders/Splats
        m_PlatformMask: 4294966271
        m_HardwareTierVariantsMask: 0
        m_StartLine: 197
        m_TypesMask: 3
        m_IncludesHash:
          serializedVersion: 2
          Hash: b2f21b964a0684e6b299d78f0232fab3
        m_CodeHash:
          serializedVersion: 2
          Hash: 00000000000000000000000000000000
        m_FromOther: 1
        m_ForceSyncCompilation: 0
        m_Language: 0
        m_VariantsUserGlobal0:
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal1:
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal2: []
        m_VariantsUserGlobal3: []
        m_VariantsUserGlobal4: []
        m_VariantsUserGlobal5: []
        m_VariantsUserGlobal6: []
        m_VariantsUserLocal0:
        - - __
          - _ALPHATEST_ON
        - - __
          - _NORMALMAP
        m_VariantsUserLocal1:
        - - __
          - _ALPHATEST_ON
        - - __
          - _NORMALMAP
        m_VariantsUserLocal2: []
        m_VariantsUserLocal3: []
        m_VariantsUserLocal4: []
        m_VariantsUserLocal5: []
        m_VariantsUserLocal6: []
        m_VariantsBuiltin0:
        - []
        - - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
        - - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
        - - LIGHTMAP_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        m_VariantsBuiltin1:
        - []
        - - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
        - - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
        - - LIGHTMAP_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        m_VariantsBuiltin2: []
        m_VariantsBuiltin3: []
        m_VariantsBuiltin4: []
        m_VariantsBuiltin5: []
        m_VariantsBuiltin6: []
        m_BaseRequirements: 227
        m_KeywordTargetInfo:
        - keywordName: SHADOWS_SOFT
          requirements: 227
        - keywordName: DIRLIGHTMAP_COMBINED
          requirements: 227
        - keywordName: DIRLIGHTMAP_SEPARATE
          requirements: 227
        - keywordName: DYNAMICLIGHTMAP_ON
          requirements: 227
        - keywordName: SHADOWS_SCREEN
          requirements: 227
        - keywordName: INSTANCING_ON
          requirements: 2048
        - keywordName: PROCEDURAL_INSTANCING_ON
          requirements: 16384
        - keywordName: STEREO_MULTIVIEW_ON
          requirements: 4075
        - keywordName: STEREO_INSTANCING_ON
          requirements: 4075
        m_NonStrippedUserKeywords: _ALPHATEST_ON _NORMALMAP FOG_LINEAR FOG_EXP FOG_EXP2
          INSTANCING_ON
        m_BuiltinKeywords: LIGHTPROBE_SH DYNAMICLIGHTMAP_ON SHADOWS_SHADOWMASK LIGHTMAP_ON
          DIRLIGHTMAP_COMBINED UNITY_HDR_ON
      341888:
        serializedVersion: 3
        m_Code: "#line 49 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n\n//
          compile directives\n#pragma vertex vert_surf\n#pragma fragment frag_surf\n#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n#pragma multi_compile_fog\n#pragma multi_compile_instancing\n#pragma
          multi_compile_fwdbase\n#include \"HLSLSupport.cginc\"\n#define UNITY_ASSUME_UNIFORM_SCALING\n#define
          UNITY_DONT_INSTANCE_OBJECT_MATRICES\n#define UNITY_INSTANCED_LOD_FADE\n#include
          \"UnityShaderVariables.cginc\"\n#include \"UnityShaderUtilities.cginc\"\n//
          -------- variant for: <when no other keywords are defined>\n#if !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD3; // SH\n  #endif\n 
          UNITY_LIGHTING_COORDS(4,5)\n  #if SHADER_TARGET >= 30\n  float4 lmap :
          TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD3; // SH\n  #endif\n 
          UNITY_SHADOW_COORDS(4)\n  #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD5;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n//
          with lightmaps:\n#ifdef LIGHTMAP_ON\n// half-precision fragment shader
          registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float4 lmap : TEXCOORD3;\n  UNITY_LIGHTING_COORDS(4,5)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float4 lmap : TEXCOORD3;\n  UNITY_SHADOW_COORDS(4)\n  #ifdef DIRLIGHTMAP_COMBINED\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: INSTANCING_ON \n#if defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          no\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD3; // SH\n  #endif\n 
          UNITY_LIGHTING_COORDS(4,5)\n  #if SHADER_TARGET >= 30\n  float4 lmap :
          TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          #if UNITY_SHOULD_SAMPLE_SH\n  half3 sh : TEXCOORD3; // SH\n  #endif\n 
          UNITY_SHADOW_COORDS(4)\n  #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD5;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n//
          with lightmaps:\n#ifdef LIGHTMAP_ON\n// half-precision fragment shader
          registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float4 lmap : TEXCOORD3;\n  UNITY_LIGHTING_COORDS(4,5)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float4 lmap : TEXCOORD3;\n  UNITY_SHADOW_COORDS(4)\n  #ifdef DIRLIGHTMAP_COMBINED\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR \n#if defined(FOG_LINEAR) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(INSTANCING_ON)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_LINEAR INSTANCING_ON \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON)
          && !defined(FOG_EXP) && !defined(FOG_EXP2)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          no\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP \n#if defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP INSTANCING_ON \n#if defined(FOG_EXP) && defined(INSTANCING_ON)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          no\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 \n#if defined(FOG_EXP2) && !defined(FOG_EXP) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n// --------
          variant for: FOG_EXP2 INSTANCING_ON \n#if defined(FOG_EXP2) && defined(INSTANCING_ON)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          no\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\n// no lightmaps:\n#ifndef LIGHTMAP_ON\n// half-precision
          fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_LIGHTING_COORDS(5,6)\n 
          #if SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n// high-precision fragment shader
          registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  #if UNITY_SHOULD_SAMPLE_SH\n 
          half3 sh : TEXCOORD4; // SH\n  #endif\n  UNITY_SHADOW_COORDS(5)\n  #if
          SHADER_TARGET >= 30\n  float4 lmap : TEXCOORD6;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n// with lightmaps:\n#ifdef
          LIGHTMAP_ON\n// half-precision fragment shader registers:\n#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_LIGHTING_COORDS(5,6)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n//
          high-precision fragment shader registers:\n#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS\nstruct
          v2f_surf {\n  UNITY_POSITION(pos);\n  float3 worldNormal : TEXCOORD0;\n 
          float3 worldPos : TEXCOORD1;\n  float4 custompack0 : TEXCOORD2; // tc\n 
          float custompack1 : TEXCOORD3; // fogCoord\n  float4 lmap : TEXCOORD4;\n 
          UNITY_SHADOW_COORDS(5)\n  #ifdef DIRLIGHTMAP_COMBINED\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n#endif\n#endif\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n 
          #ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n  #endif\n  #ifdef LIGHTMAP_ON\n  o.lmap.xy
          = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n  #endif\n\n 
          // SH/ambient and vertex lights\n  #ifndef LIGHTMAP_ON\n    #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n      o.sh = 0;\n      // Approximated
          illumination from non-important point lights\n      #ifdef VERTEXLIGHT_ON\n       
          o.sh += Shade4PointLights (\n          unity_4LightPosX0, unity_4LightPosY0,
          unity_4LightPosZ0,\n          unity_LightColor[0].rgb, unity_LightColor[1].rgb,
          unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n          unity_4LightAtten0,
          worldPos, worldNormal);\n      #endif\n      o.sh = ShadeSHPerVertex (worldNormal,
          o.sh);\n    #endif\n  #endif // !LIGHTMAP_ON\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // compute lighting
          & shadowing factor\n  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)\n  fixed4
          c = 0;\n\n  // Setup lighting environment\n  UnityGI gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI,
          gi);\n  gi.indirect.diffuse = 0;\n  gi.indirect.specular = 0;\n  gi.light.color
          = _LightColor0.rgb;\n  gi.light.dir = lightDir;\n  // Call GI (lightmaps/SH/reflections)
          lighting function\n  UnityGIInput giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput,
          giInput);\n  giInput.light = gi.light;\n  giInput.worldPos = worldPos;\n 
          giInput.atten = atten;\n  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n   
          giInput.lightmapUV = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n 
          #endif\n  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n   
          giInput.ambient = IN.sh;\n  #else\n    giInput.ambient.rgb = 0.0;\n  #endif\n 
          giInput.probeHDR[0] = unity_SpecCube0_HDR;\n  giInput.probeHDR[1] = unity_SpecCube1_HDR;\n 
          #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n   
          giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for
          blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n    giInput.boxMax[0]
          = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n   
          giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n    giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n   
          giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n  #endif\n 
          LightingLambert_GI(o, giInput, gi);\n\n  // realtime lighting: call lighting
          function\n  c += LightingLambert (o, gi);\n  SplatmapFinalColor (surfIN,
          o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n  return c;\n}\n\n\n#endif\n\n\n"
        m_AssetPath: Assets/DefaultResourcesExtra/TerrainShaders/Splats
        m_PlatformMask: 4294967295
        m_HardwareTierVariantsMask: 0
        m_StartLine: 51
        m_TypesMask: 3
        m_IncludesHash:
          serializedVersion: 2
          Hash: 3ee3b648a41f870b7ce2234ae20da796
        m_CodeHash:
          serializedVersion: 2
          Hash: 00000000000000000000000000000000
        m_FromOther: 1
        m_ForceSyncCompilation: 0
        m_Language: 0
        m_VariantsUserGlobal0:
        - - __
          - FOG_LINEAR
          - FOG_EXP
          - FOG_EXP2
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal1:
        - - __
          - FOG_LINEAR
          - FOG_EXP
          - FOG_EXP2
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal2: []
        m_VariantsUserGlobal3: []
        m_VariantsUserGlobal4: []
        m_VariantsUserGlobal5: []
        m_VariantsUserGlobal6: []
        m_VariantsUserLocal0: []
        m_VariantsUserLocal1: []
        m_VariantsUserLocal2: []
        m_VariantsUserLocal3: []
        m_VariantsUserLocal4: []
        m_VariantsUserLocal5: []
        m_VariantsUserLocal6: []
        m_VariantsBuiltin0:
        - - DIRECTIONAL
        - - DIRECTIONAL
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - VERTEXLIGHT_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        m_VariantsBuiltin1:
        - - DIRECTIONAL
        - - DIRECTIONAL
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
          - LIGHTPROBE_SH
        - - DIRECTIONAL
          - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        m_VariantsBuiltin2: []
        m_VariantsBuiltin3: []
        m_VariantsBuiltin4: []
        m_VariantsBuiltin5: []
        m_VariantsBuiltin6: []
        m_BaseRequirements: 33
        m_KeywordTargetInfo:
        - keywordName: SHADOWS_SOFT
          requirements: 227
        - keywordName: DIRLIGHTMAP_COMBINED
          requirements: 227
        - keywordName: DIRLIGHTMAP_SEPARATE
          requirements: 227
        - keywordName: DYNAMICLIGHTMAP_ON
          requirements: 227
        - keywordName: SHADOWS_SCREEN
          requirements: 227
        - keywordName: INSTANCING_ON
          requirements: 2048
        - keywordName: PROCEDURAL_INSTANCING_ON
          requirements: 16384
        - keywordName: STEREO_MULTIVIEW_ON
          requirements: 4075
        - keywordName: STEREO_INSTANCING_ON
          requirements: 4075
        m_NonStrippedUserKeywords: FOG_LINEAR FOG_EXP FOG_EXP2 INSTANCING_ON
        m_BuiltinKeywords: DIRECTIONAL LIGHTPROBE_SH SHADOWS_SHADOWMASK DYNAMICLIGHTMAP_ON
          LIGHTMAP_ON LIGHTMAP_SHADOW_MIXING DIRLIGHTMAP_COMBINED SHADOWS_SCREEN
          VERTEXLIGHT_ON
      456651:
        serializedVersion: 3
        m_Code: "#line 268 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n\n//
          compile directives\n#pragma vertex vert_surf\n#pragma fragment frag_surf\n#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n#pragma multi_compile_fog\n#pragma multi_compile_instancing\n#pragma
          multi_compile_fwdadd_fullshadows\n#include \"HLSLSupport.cginc\"\n#define
          UNITY_ASSUME_UNIFORM_SCALING\n#define UNITY_DONT_INSTANCE_OBJECT_MATRICES\n#define
          UNITY_INSTANCED_LOD_FADE\n#include \"UnityShaderVariables.cginc\"\n#include
          \"UnityShaderUtilities.cginc\"\n// -------- variant for: <when no other
          keywords are defined>\n#if !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  UNITY_LIGHTING_COORDS(3,4)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: INSTANCING_ON \n#if
          defined(INSTANCING_ON) && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  UNITY_LIGHTING_COORDS(3,4)\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR \n#if defined(FOG_LINEAR)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR INSTANCING_ON
          \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          no\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP \n#if defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP INSTANCING_ON
          \n#if defined(FOG_EXP) && defined(INSTANCING_ON) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 \n#if defined(FOG_EXP2)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n#include \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define
          WorldReflectionVector(data,normal) data.worldRefl\n#define WorldNormalVector(data,normal)
          normal\n\n// Original surface shader snippet:\n#line 6\n\n        //#pragma
          surface surf Lambert decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor
          finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
          nometa\n        //#pragma instancing_options assumeuniformscaling nomatrices
          nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 INSTANCING_ON
          \n#if defined(FOG_EXP2) && defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_LINEAR)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n#include
          \"AutoLight.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_LIGHTING_COORDS(4,5)\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n\n  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy);
          // pass shadow and, possibly, light cookie coordinates to pixel shader\n 
          return o;\n}\n\n// fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target
          {\n  UNITY_SETUP_INSTANCE_ID(IN);\n  // prepare and unpack data\n  Input
          surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n  surfIN.tc.x = 1.0;\n 
          surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  surfIN.fogCoord
          = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n   
          fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n   
          fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n  UNITY_LIGHT_ATTENUATION(atten,
          IN, worldPos)\n  fixed4 c = 0;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = _LightColor0.rgb;\n  gi.light.dir
          = lightDir;\n  gi.light.color *= atten;\n  c += LightingLambert (o, gi);\n 
          c.a = 0.0;\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n\n"
        m_AssetPath: Assets/DefaultResourcesExtra/TerrainShaders/Splats
        m_PlatformMask: 4294967295
        m_HardwareTierVariantsMask: 0
        m_StartLine: 270
        m_TypesMask: 3
        m_IncludesHash:
          serializedVersion: 2
          Hash: 3ee3b648a41f870b7ce2234ae20da796
        m_CodeHash:
          serializedVersion: 2
          Hash: 00000000000000000000000000000000
        m_FromOther: 1
        m_ForceSyncCompilation: 0
        m_Language: 0
        m_VariantsUserGlobal0:
        - - __
          - FOG_LINEAR
          - FOG_EXP
          - FOG_EXP2
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal1:
        - - __
          - FOG_LINEAR
          - FOG_EXP
          - FOG_EXP2
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal2: []
        m_VariantsUserGlobal3: []
        m_VariantsUserGlobal4: []
        m_VariantsUserGlobal5: []
        m_VariantsUserGlobal6: []
        m_VariantsUserLocal0: []
        m_VariantsUserLocal1: []
        m_VariantsUserLocal2: []
        m_VariantsUserLocal3: []
        m_VariantsUserLocal4: []
        m_VariantsUserLocal5: []
        m_VariantsUserLocal6: []
        m_VariantsBuiltin0:
        - - POINT
        - - DIRECTIONAL
        - - SPOT
        - - POINT_COOKIE
        - - DIRECTIONAL_COOKIE
        - - POINT
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - SHADOWS_SHADOWMASK
        - - SPOT
          - SHADOWS_SHADOWMASK
        - - POINT_COOKIE
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SHADOWMASK
        - - POINT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
        - - SPOT
          - SHADOWS_DEPTH
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SHADOWMASK
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SCREEN
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
        - - POINT
          - SHADOWS_CUBE
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        m_VariantsBuiltin1:
        - - POINT
        - - DIRECTIONAL
        - - SPOT
        - - POINT_COOKIE
        - - DIRECTIONAL_COOKIE
        - - POINT
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - SHADOWS_SHADOWMASK
        - - SPOT
          - SHADOWS_SHADOWMASK
        - - POINT_COOKIE
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SHADOWMASK
        - - POINT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
        - - SPOT
          - SHADOWS_DEPTH
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SHADOWMASK
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - SPOT
          - SHADOWS_DEPTH
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SCREEN
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
        - - DIRECTIONAL
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - DIRECTIONAL_COOKIE
          - SHADOWS_SCREEN
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
        - - POINT
          - SHADOWS_CUBE
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        - - POINT_COOKIE
          - SHADOWS_CUBE
          - SHADOWS_SOFT
          - SHADOWS_SHADOWMASK
          - LIGHTMAP_SHADOW_MIXING
        m_VariantsBuiltin2: []
        m_VariantsBuiltin3: []
        m_VariantsBuiltin4: []
        m_VariantsBuiltin5: []
        m_VariantsBuiltin6: []
        m_BaseRequirements: 33
        m_KeywordTargetInfo:
        - keywordName: SHADOWS_SOFT
          requirements: 227
        - keywordName: DIRLIGHTMAP_COMBINED
          requirements: 227
        - keywordName: DIRLIGHTMAP_SEPARATE
          requirements: 227
        - keywordName: DYNAMICLIGHTMAP_ON
          requirements: 227
        - keywordName: SHADOWS_SCREEN
          requirements: 227
        - keywordName: INSTANCING_ON
          requirements: 2048
        - keywordName: PROCEDURAL_INSTANCING_ON
          requirements: 16384
        - keywordName: STEREO_MULTIVIEW_ON
          requirements: 4075
        - keywordName: STEREO_INSTANCING_ON
          requirements: 4075
        m_NonStrippedUserKeywords: FOG_LINEAR FOG_EXP FOG_EXP2 INSTANCING_ON
        m_BuiltinKeywords: POINT DIRECTIONAL SPOT POINT_COOKIE DIRECTIONAL_COOKIE
          SHADOWS_SHADOWMASK LIGHTMAP_SHADOW_MIXING SHADOWS_DEPTH SHADOWS_SOFT SHADOWS_SCREEN
          SHADOWS_CUBE
      511832:
        serializedVersion: 3
        m_Code: "#line 138 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n\n//
          compile directives\n#pragma vertex vert_surf\n#pragma fragment frag_surf\n#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n#pragma multi_compile_fog\n#pragma multi_compile_instancing\n#pragma
          skip_variants FOG_LINEAR FOG_EXP FOG_EXP2\n\n#include \"HLSLSupport.cginc\"\n#define
          UNITY_ASSUME_UNIFORM_SCALING\n#define UNITY_DONT_INSTANCE_OBJECT_MATRICES\n#define
          UNITY_INSTANCED_LOD_FADE\n#include \"UnityShaderVariables.cginc\"\n#include
          \"UnityShaderUtilities.cginc\"\n// -------- variant for: <when no other
          keywords are defined>\n#if !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)
          && !defined(INSTANCING_ON)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: INSTANCING_ON \n#if defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          no\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_LINEAR \n#if defined(FOG_LINEAR) && !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(INSTANCING_ON)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_LINEAR INSTANCING_ON \n#if defined(FOG_LINEAR)
          && defined(INSTANCING_ON) && !defined(FOG_EXP) && !defined(FOG_EXP2)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP \n#if defined(FOG_EXP) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP INSTANCING_ON \n#if defined(FOG_EXP) && defined(INSTANCING_ON)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR)\n// Surface shader code generated
          based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal:
          no\n// writes to emission: no\n// writes to occlusion: no\n// needs world
          space reflection vector: no\n// needs world space normal vector: no\n//
          needs screen space position: no\n// needs world space position: no\n//
          needs view direction: no\n// needs world space view direction: no\n// needs
          world space position for lighting: YES\n// needs world space view direction
          for lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP2 \n#if defined(FOG_EXP2) && !defined(FOG_EXP)
          && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n// Surface shader code
          generated based on:\n// vertex modifier: 'SplatmapVert'\n// writes to per-pixel
          normal: no\n// writes to emission: no\n// writes to occlusion: no\n// needs
          world space reflection vector: no\n// needs world space normal vector:
          no\n// needs screen space position: no\n// needs world space position:
          no\n// needs view direction: no\n// needs world space view direction: no\n//
          needs world space position for lighting: YES\n// needs world space view
          direction for lighting: no\n// needs world space view direction for lightmaps:
          no\n// needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n//
          -------- variant for: FOG_EXP2 INSTANCING_ON \n#if defined(FOG_EXP2) &&
          defined(INSTANCING_ON) && !defined(FOG_EXP) && !defined(FOG_LINEAR)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.custompack1.x = customInputData.fogCoord;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          o.worldPos.xyz = worldPos;\n  o.worldNormal = worldNormal;\n  return o;\n}\n\n//
          fragment shader\nfixed4 frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\n\n  // output normal and
          specular\n  fixed4 res;\n  res.rgb = o.Normal * 0.5 + 0.5;\n  res.a = o.Specular;\n 
          SplatmapFinalPrepass (surfIN, o, res);\n  return res;\n}\n\n\n#endif\n\n\n"
        m_AssetPath: Assets/DefaultResourcesExtra/TerrainShaders/Splats
        m_PlatformMask: 4294967295
        m_HardwareTierVariantsMask: 0
        m_StartLine: 140
        m_TypesMask: 3
        m_IncludesHash:
          serializedVersion: 2
          Hash: b2f21b964a0684e6b299d78f0232fab3
        m_CodeHash:
          serializedVersion: 2
          Hash: 00000000000000000000000000000000
        m_FromOther: 1
        m_ForceSyncCompilation: 0
        m_Language: 0
        m_VariantsUserGlobal0:
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal1:
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal2: []
        m_VariantsUserGlobal3: []
        m_VariantsUserGlobal4: []
        m_VariantsUserGlobal5: []
        m_VariantsUserGlobal6: []
        m_VariantsUserLocal0: []
        m_VariantsUserLocal1: []
        m_VariantsUserLocal2: []
        m_VariantsUserLocal3: []
        m_VariantsUserLocal4: []
        m_VariantsUserLocal5: []
        m_VariantsUserLocal6: []
        m_VariantsBuiltin0: []
        m_VariantsBuiltin1: []
        m_VariantsBuiltin2: []
        m_VariantsBuiltin3: []
        m_VariantsBuiltin4: []
        m_VariantsBuiltin5: []
        m_VariantsBuiltin6: []
        m_BaseRequirements: 33
        m_KeywordTargetInfo:
        - keywordName: SHADOWS_SOFT
          requirements: 227
        - keywordName: DIRLIGHTMAP_COMBINED
          requirements: 227
        - keywordName: DIRLIGHTMAP_SEPARATE
          requirements: 227
        - keywordName: DYNAMICLIGHTMAP_ON
          requirements: 227
        - keywordName: SHADOWS_SCREEN
          requirements: 227
        - keywordName: INSTANCING_ON
          requirements: 2048
        - keywordName: PROCEDURAL_INSTANCING_ON
          requirements: 16384
        - keywordName: STEREO_MULTIVIEW_ON
          requirements: 4075
        - keywordName: STEREO_INSTANCING_ON
          requirements: 4075
        m_NonStrippedUserKeywords: FOG_LINEAR FOG_EXP FOG_EXP2 INSTANCING_ON
        m_BuiltinKeywords: 
      547886:
        serializedVersion: 3
        m_Code: "#line 127 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n\n//
          compile directives\n#pragma vertex vert_surf\n#pragma fragment frag_surf\n#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n#pragma multi_compile_fog\n#pragma multi_compile_instancing\n#pragma
          multi_compile_prepassfinal\n#include \"HLSLSupport.cginc\"\n#define UNITY_ASSUME_UNIFORM_SCALING\n#define
          UNITY_DONT_INSTANCE_OBJECT_MATRICES\n#define UNITY_INSTANCED_LOD_FADE\n#include
          \"UnityShaderVariables.cginc\"\n#include \"UnityShaderUtilities.cginc\"\n//
          -------- variant for: <when no other keywords are defined>\n#if !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float4
          screen : TEXCOORD2;\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          float3 vlight : TEXCOORD4;\n#else\n#ifdef DIRLIGHTMAP_OFF\n  float4 lmapFadePos
          : TEXCOORD4;\n#endif\n#endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n\n 
          // call surface function\n  surf (surfIN, o);\n  half4 light = tex2Dproj
          (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if defined (SHADER_API_MOBILE)\n 
          light = max(light, half4(0.001, 0.001, 0.001, 0.001));\n#endif\n#ifndef
          UNITY_HDR_ON\n  light = -log2(light);\n#endif\n  #ifdef LIGHTMAP_ON\n   
          #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n      fixed4 lmtex =
          UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3 lm = DecodeLightmap
          (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: INSTANCING_ON \n#if
          defined(INSTANCING_ON) && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float4
          screen : TEXCOORD2;\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          float3 vlight : TEXCOORD4;\n#else\n#ifdef DIRLIGHTMAP_OFF\n  float4 lmapFadePos
          : TEXCOORD4;\n#endif\n#endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          float3 tSpace0 : TEXCOORD5;\n  float3 tSpace1 : TEXCOORD6;\n  float3 tSpace2
          : TEXCOORD7;\n  #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.pos = UnityObjectToClipPos(v.vertex);\n  float3 worldPos = mul(unity_ObjectToWorld,
          v.vertex).xyz;\n  float3 worldNormal = UnityObjectToWorldNormal(v.normal);\n 
          #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  fixed3 worldTangent
          = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign = v.tangent.w
          * unity_WorldTransformParams.w;\n  fixed3 worldBinormal = cross(worldNormal,
          worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)
          && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n  o.tSpace0
          = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n\n 
          // call surface function\n  surf (surfIN, o);\n  half4 light = tex2Dproj
          (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if defined (SHADER_API_MOBILE)\n 
          light = max(light, half4(0.001, 0.001, 0.001, 0.001));\n#endif\n#ifndef
          UNITY_HDR_ON\n  light = -log2(light);\n#endif\n  #ifdef LIGHTMAP_ON\n   
          #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n      fixed4 lmtex =
          UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3 lm = DecodeLightmap
          (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR \n#if defined(FOG_LINEAR)
          && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR INSTANCING_ON
          \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          no\n// reads from normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP \n#if defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP INSTANCING_ON
          \n#if defined(FOG_EXP) && defined(INSTANCING_ON) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 \n#if defined(FOG_EXP2)
          && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: no\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 INSTANCING_ON
          \n#if defined(FOG_EXP2) && defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_LINEAR)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: no\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldPos : TEXCOORD0;\n  float4 custompack0 : TEXCOORD1; // tc\n  float
          custompack1 : TEXCOORD2; // fogCoord\n  float4 screen : TEXCOORD3;\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  float3 vlight : TEXCOORD5;\n#else\n#ifdef
          DIRLIGHTMAP_OFF\n  float4 lmapFadePos : TEXCOORD5;\n#endif\n#endif\n  #if
          defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n  float3 tSpace0
          : TEXCOORD6;\n  float3 tSpace1 : TEXCOORD7;\n  float3 tSpace2 : TEXCOORD8;\n 
          #endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  #if defined(LIGHTMAP_ON) && defined(DIRLIGHTMAP_COMBINED)\n 
          fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\n  fixed tangentSign
          = v.tangent.w * unity_WorldTransformParams.w;\n  fixed3 worldBinormal =
          cross(worldNormal, worldTangent) * tangentSign;\n  #endif\n  #if defined(LIGHTMAP_ON)
          && defined(DIRLIGHTMAP_COMBINED) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)\n 
          o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\n 
          o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\n 
          o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\n 
          #endif\n  o.worldPos.xyz = worldPos;\n  o.screen = ComputeScreenPos (o.pos);\n#ifdef
          DYNAMICLIGHTMAP_ON\n  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
          + unity_DynamicLightmapST.zw;\n#else\n  o.lmap.zw = 0;\n#endif\n#ifdef
          LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n 
          #ifdef DIRLIGHTMAP_OFF\n    o.lmapFadePos.xyz = (mul(unity_ObjectToWorld,
          v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n   
          o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n 
          #endif\n#else\n  o.lmap.xy = 0;\n  float3 worldN = UnityObjectToWorldNormal(v.normal);\n 
          o.vlight = ShadeSH9 (float4(worldN,1.0));\n#endif\n  return o;\n}\nsampler2D
          _LightBuffer;\nsampler2D _CameraNormalsTexture;\n#ifdef LIGHTMAP_ON\nfloat4
          unity_LightmapFade;\n#endif\nfixed4 unity_Ambient;\n\n// fragment shader\nfixed4
          frag_surf (v2f_surf IN) : SV_Target {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n\n  // call surface function\n  surf (surfIN, o);\n 
          half4 light = tex2Dproj (_LightBuffer, UNITY_PROJ_COORD(IN.screen));\n#if
          defined (SHADER_API_MOBILE)\n  light = max(light, half4(0.001, 0.001, 0.001,
          0.001));\n#endif\n#ifndef UNITY_HDR_ON\n  light = -log2(light);\n#endif\n 
          #ifdef LIGHTMAP_ON\n    #ifdef DIRLIGHTMAP_OFF\n      // single lightmap\n     
          fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap, IN.lmap.xy);\n      fixed3
          lm = DecodeLightmap (lmtex);\n      light.rgb += lm;\n    #elif DIRLIGHTMAP_COMBINED\n     
          half4 nspec = tex2Dproj (_CameraNormalsTexture, UNITY_PROJ_COORD(IN.screen));\n     
          half3 normal = nspec.rgb * 2 - 1;\n      o.Normal = normalize(normal);\n     
          // directional lightmaps\n      fixed4 lmtex = UNITY_SAMPLE_TEX2D(unity_Lightmap,
          IN.lmap.xy);\n      half4 lm = half4(DecodeLightmap(lmtex), 0);\n     
          light += lm;\n    #endif // DIRLIGHTMAP_OFF\n  #else\n    light.rgb +=
          IN.vlight;\n  #endif // LIGHTMAP_ON\n\n  #ifdef DYNAMICLIGHTMAP_ON\n  fixed4
          dynlmtex = UNITY_SAMPLE_TEX2D(unity_DynamicLightmap, IN.lmap.zw);\n  light.rgb
          += DecodeRealtimeLightmap (dynlmtex);\n  #endif\n\n  fixed4 c = LightingLambert_PrePass
          (o, light);\n  SplatmapFinalColor (surfIN, o, c);\n  UNITY_OPAQUE_ALPHA(c.a);\n 
          return c;\n}\n\n\n#endif\n\n\n"
        m_AssetPath: Assets/DefaultResourcesExtra/TerrainShaders/Splats
        m_PlatformMask: 4294967295
        m_HardwareTierVariantsMask: 0
        m_StartLine: 129
        m_TypesMask: 3
        m_IncludesHash:
          serializedVersion: 2
          Hash: b2f21b964a0684e6b299d78f0232fab3
        m_CodeHash:
          serializedVersion: 2
          Hash: 00000000000000000000000000000000
        m_FromOther: 1
        m_ForceSyncCompilation: 0
        m_Language: 0
        m_VariantsUserGlobal0:
        - - __
          - FOG_LINEAR
          - FOG_EXP
          - FOG_EXP2
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal1:
        - - __
          - FOG_LINEAR
          - FOG_EXP
          - FOG_EXP2
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal2: []
        m_VariantsUserGlobal3: []
        m_VariantsUserGlobal4: []
        m_VariantsUserGlobal5: []
        m_VariantsUserGlobal6: []
        m_VariantsUserLocal0: []
        m_VariantsUserLocal1: []
        m_VariantsUserLocal2: []
        m_VariantsUserLocal3: []
        m_VariantsUserLocal4: []
        m_VariantsUserLocal5: []
        m_VariantsUserLocal6: []
        m_VariantsBuiltin0:
        - []
        - - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
        - - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
        - - LIGHTMAP_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        m_VariantsBuiltin1:
        - []
        - - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
        - - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
        - - LIGHTMAP_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        m_VariantsBuiltin2: []
        m_VariantsBuiltin3: []
        m_VariantsBuiltin4: []
        m_VariantsBuiltin5: []
        m_VariantsBuiltin6: []
        m_BaseRequirements: 33
        m_KeywordTargetInfo:
        - keywordName: SHADOWS_SOFT
          requirements: 227
        - keywordName: DIRLIGHTMAP_COMBINED
          requirements: 227
        - keywordName: DIRLIGHTMAP_SEPARATE
          requirements: 227
        - keywordName: DYNAMICLIGHTMAP_ON
          requirements: 227
        - keywordName: SHADOWS_SCREEN
          requirements: 227
        - keywordName: INSTANCING_ON
          requirements: 2048
        - keywordName: PROCEDURAL_INSTANCING_ON
          requirements: 16384
        - keywordName: STEREO_MULTIVIEW_ON
          requirements: 4075
        - keywordName: STEREO_INSTANCING_ON
          requirements: 4075
        m_NonStrippedUserKeywords: FOG_LINEAR FOG_EXP FOG_EXP2 INSTANCING_ON
        m_BuiltinKeywords: LIGHTPROBE_SH DYNAMICLIGHTMAP_ON SHADOWS_SHADOWMASK LIGHTMAP_ON
          DIRLIGHTMAP_COMBINED UNITY_HDR_ON
      628245:
        serializedVersion: 3
        m_Code: "#line 198 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n\n//
          compile directives\n#pragma vertex vert_surf\n#pragma fragment frag_surf\n#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n#pragma multi_compile_fog\n#pragma multi_compile_instancing\n#pragma
          exclude_renderers nomrt\n#pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2\n#pragma
          multi_compile_prepassfinal\n#include \"HLSLSupport.cginc\"\n#define UNITY_ASSUME_UNIFORM_SCALING\n#define
          UNITY_DONT_INSTANCE_OBJECT_MATRICES\n#define UNITY_INSTANCED_LOD_FADE\n#include
          \"UnityShaderVariables.cginc\"\n#include \"UnityShaderUtilities.cginc\"\n//
          -------- variant for: <when no other keywords are defined>\n#if !defined(FOG_EXP)
          && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD4; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD4;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: INSTANCING_ON
          \n#if defined(INSTANCING_ON) && !defined(FOG_EXP) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float4 lmap : TEXCOORD3;\n#ifndef LIGHTMAP_ON\n 
          #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3
          sh : TEXCOORD4; // SH\n  #endif\n#else\n  #ifdef DIRLIGHTMAP_OFF\n    float4
          lmapFadePos : TEXCOORD4;\n  #endif\n#endif\n  UNITY_VERTEX_INPUT_INSTANCE_ID\n 
          UNITY_VERTEX_OUTPUT_STEREO\n};\n\n// vertex shader\nv2f_surf vert_surf
          (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n  v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n 
          UNITY_TRANSFER_INSTANCE_ID(v,o);\n  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n 
          Input customInputData;\n  SplatmapVert (v, customInputData);\n  o.custompack0.xyzw
          = customInputData.tc;\n  o.pos = UnityObjectToClipPos(v.vertex);\n  float3
          worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n  float3 worldPos
          = IN.worldPos.xyz;\n  #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir
          = normalize(UnityWorldSpaceLightDir(worldPos));\n  #else\n    fixed3 lightDir
          = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef UNITY_COMPILER_HLSL\n 
          SurfaceOutput o = (SurfaceOutput)0;\n  #else\n  SurfaceOutput o;\n  #endif\n 
          o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular = 0.0;\n  o.Alpha =
          0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex = fixed3(0,0,1);\n 
          o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR \n#if
          defined(FOG_LINEAR) && !defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_LINEAR INSTANCING_ON
          \n#if defined(FOG_LINEAR) && defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_EXP2)\n// Surface shader code generated based on:\n// vertex
          modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n// writes
          to emission: no\n// writes to occlusion: no\n// needs world space reflection
          vector: no\n// needs world space normal vector: no\n// needs screen space
          position: no\n// needs world space position: no\n// needs view direction:
          no\n// needs world space view direction: no\n// needs world space position
          for lighting: YES\n// needs world space view direction for lighting: no\n//
          needs world space view direction for lightmaps: no\n// needs vertex color:
          no\n// needs VFACE: no\n// passes tangent-to-world matrix to pixel shader:
          no\n// reads from normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP \n#if
          defined(FOG_EXP) && !defined(FOG_EXP2) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP INSTANCING_ON
          \n#if defined(FOG_EXP) && defined(INSTANCING_ON) && !defined(FOG_EXP2)
          && !defined(FOG_LINEAR)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 \n#if
          defined(FOG_EXP2) && !defined(FOG_EXP) && !defined(FOG_LINEAR) && !defined(INSTANCING_ON)\n//
          Surface shader code generated based on:\n// vertex modifier: 'SplatmapVert'\n//
          writes to per-pixel normal: no\n// writes to emission: no\n// writes to
          occlusion: no\n// needs world space reflection vector: no\n// needs world
          space normal vector: no\n// needs screen space position: no\n// needs world
          space position: no\n// needs view direction: no\n// needs world space view
          direction: no\n// needs world space position for lighting: YES\n// needs
          world space view direction for lighting: no\n// needs world space view
          direction for lightmaps: no\n// needs vertex color: no\n// needs VFACE:
          no\n// passes tangent-to-world matrix to pixel shader: no\n// reads from
          normal: YES\n// 0 texcoords actually used\n#include \"UnityCG.cginc\"\n#include
          \"Lighting.cginc\"\n\n#define INTERNAL_DATA\n#define WorldReflectionVector(data,normal)
          data.worldRefl\n#define WorldNormalVector(data,normal) normal\n\n// Original
          surface shader snippet:\n#line 6\n\n        //#pragma surface surf Lambert
          decal:add vertex:SplatmapVert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass
          finalgbuffer:SplatmapFinalGBuffer fullforwardshadows nometa\n        //#pragma
          instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
          forwardadd\n        //#pragma multi_compile_fog\n\n        #define TERRAIN_SPLAT_ADDPASS\n       
          #include \"TerrainSplatmapCommon.cginc\"\n\n        void surf(Input IN,
          inout SurfaceOutput o)\n        {\n            half4 splat_control;\n           
          half weight;\n            fixed4 mixedDiffuse;\n            SplatmapMix(IN,
          splat_control, weight, mixedDiffuse, o.Normal);\n            o.Albedo =
          mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n    #line
          38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n// -------- variant for: FOG_EXP2 INSTANCING_ON
          \n#if defined(FOG_EXP2) && defined(INSTANCING_ON) && !defined(FOG_EXP)
          && !defined(FOG_LINEAR)\n// Surface shader code generated based on:\n//
          vertex modifier: 'SplatmapVert'\n// writes to per-pixel normal: no\n//
          writes to emission: no\n// writes to occlusion: no\n// needs world space
          reflection vector: no\n// needs world space normal vector: no\n// needs
          screen space position: no\n// needs world space position: no\n// needs
          view direction: no\n// needs world space view direction: no\n// needs world
          space position for lighting: YES\n// needs world space view direction for
          lighting: no\n// needs world space view direction for lightmaps: no\n//
          needs vertex color: no\n// needs VFACE: no\n// passes tangent-to-world
          matrix to pixel shader: no\n// reads from normal: YES\n// 0 texcoords actually
          used\n#include \"UnityCG.cginc\"\n#include \"Lighting.cginc\"\n\n#define
          INTERNAL_DATA\n#define WorldReflectionVector(data,normal) data.worldRefl\n#define
          WorldNormalVector(data,normal) normal\n\n// Original surface shader snippet:\n#line
          6\n\n        //#pragma surface surf Lambert decal:add vertex:SplatmapVert
          finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer
          fullforwardshadows nometa\n        //#pragma instancing_options assumeuniformscaling
          nomatrices nolightprobe nolightmap forwardadd\n        //#pragma multi_compile_fog\n\n       
          #define TERRAIN_SPLAT_ADDPASS\n        #include \"TerrainSplatmapCommon.cginc\"\n\n       
          void surf(Input IN, inout SurfaceOutput o)\n        {\n            half4
          splat_control;\n            half weight;\n            fixed4 mixedDiffuse;\n           
          SplatmapMix(IN, splat_control, weight, mixedDiffuse, o.Normal);\n           
          o.Albedo = mixedDiffuse.rgb;\n            o.Alpha = weight;\n        }\n   
          #line 38 \"\"\n#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING\n#endif\n/*
          UNITY: Original start of shader */\n            \n\n// vertex-to-fragment
          interpolation data\nstruct v2f_surf {\n  UNITY_POSITION(pos);\n  float3
          worldNormal : TEXCOORD0;\n  float3 worldPos : TEXCOORD1;\n  float4 custompack0
          : TEXCOORD2; // tc\n  float custompack1 : TEXCOORD3; // fogCoord\n  float4
          lmap : TEXCOORD4;\n#ifndef LIGHTMAP_ON\n  #if UNITY_SHOULD_SAMPLE_SH &&
          !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    half3 sh : TEXCOORD5; // SH\n  #endif\n#else\n 
          #ifdef DIRLIGHTMAP_OFF\n    float4 lmapFadePos : TEXCOORD5;\n  #endif\n#endif\n 
          UNITY_VERTEX_INPUT_INSTANCE_ID\n  UNITY_VERTEX_OUTPUT_STEREO\n};\n\n//
          vertex shader\nv2f_surf vert_surf (appdata_full v) {\n  UNITY_SETUP_INSTANCE_ID(v);\n 
          v2f_surf o;\n  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);\n  UNITY_TRANSFER_INSTANCE_ID(v,o);\n 
          UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n  Input customInputData;\n 
          SplatmapVert (v, customInputData);\n  o.custompack0.xyzw = customInputData.tc;\n 
          o.custompack1.x = customInputData.fogCoord;\n  o.pos = UnityObjectToClipPos(v.vertex);\n 
          float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n  float3 worldNormal
          = UnityObjectToWorldNormal(v.normal);\n  o.worldPos.xyz = worldPos;\n 
          o.worldNormal = worldNormal;\n#ifdef DYNAMICLIGHTMAP_ON\n  o.lmap.zw =
          v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n#else\n 
          o.lmap.zw = 0;\n#endif\n#ifdef LIGHTMAP_ON\n  o.lmap.xy = v.texcoord1.xy
          * unity_LightmapST.xy + unity_LightmapST.zw;\n  #ifdef DIRLIGHTMAP_OFF\n   
          o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz)
          * unity_ShadowFadeCenterAndType.w;\n    o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z)
          * (1.0 - unity_ShadowFadeCenterAndType.w);\n  #endif\n#else\n  o.lmap.xy
          = 0;\n    #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n     
          o.sh = 0;\n      o.sh = ShadeSHPerVertex (worldNormal, o.sh);\n    #endif\n#endif\n 
          return o;\n}\n#ifdef LIGHTMAP_ON\nfloat4 unity_LightmapFade;\n#endif\nfixed4
          unity_Ambient;\n\n// fragment shader\nvoid frag_surf (v2f_surf IN,\n   
          out half4 outGBuffer0 : SV_Target0,\n    out half4 outGBuffer1 : SV_Target1,\n   
          out half4 outGBuffer2 : SV_Target2,\n    out half4 outEmission : SV_Target3\n#if
          defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    , out
          half4 outShadowMask : SV_Target4\n#endif\n) {\n  UNITY_SETUP_INSTANCE_ID(IN);\n 
          // prepare and unpack data\n  Input surfIN;\n  UNITY_INITIALIZE_OUTPUT(Input,surfIN);\n 
          surfIN.tc.x = 1.0;\n  surfIN.fogCoord.x = 1.0;\n  surfIN.tc = IN.custompack0.xyzw;\n 
          surfIN.fogCoord = IN.custompack1.x;\n  float3 worldPos = IN.worldPos.xyz;\n 
          #ifndef USING_DIRECTIONAL_LIGHT\n    fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));\n 
          #else\n    fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n  #endif\n  #ifdef
          UNITY_COMPILER_HLSL\n  SurfaceOutput o = (SurfaceOutput)0;\n  #else\n 
          SurfaceOutput o;\n  #endif\n  o.Albedo = 0.0;\n  o.Emission = 0.0;\n  o.Specular
          = 0.0;\n  o.Alpha = 0.0;\n  o.Gloss = 0.0;\n  fixed3 normalWorldVertex
          = fixed3(0,0,1);\n  o.Normal = IN.worldNormal;\n  normalWorldVertex = IN.worldNormal;\n\n 
          // call surface function\n  surf (surfIN, o);\nfixed3 originalNormal =
          o.Normal;\n  half atten = 1;\n\n  // Setup lighting environment\n  UnityGI
          gi;\n  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n  gi.indirect.diffuse = 0;\n 
          gi.indirect.specular = 0;\n  gi.light.color = 0;\n  gi.light.dir = half3(0,1,0);\n 
          // Call GI (lightmaps/SH/reflections) lighting function\n  UnityGIInput
          giInput;\n  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n  giInput.light
          = gi.light;\n  giInput.worldPos = worldPos;\n  giInput.atten = atten;\n 
          #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n    giInput.lightmapUV
          = IN.lmap;\n  #else\n    giInput.lightmapUV = 0.0;\n  #endif\n  #if UNITY_SHOULD_SAMPLE_SH
          && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n    giInput.ambient = IN.sh;\n  #else\n   
          giInput.ambient.rgb = 0.0;\n  #endif\n  giInput.probeHDR[0] = unity_SpecCube0_HDR;\n 
          giInput.probeHDR[1] = unity_SpecCube1_HDR;\n  #if defined(UNITY_SPECCUBE_BLENDING)
          || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n    giInput.boxMin[0] = unity_SpecCube0_BoxMin;
          // .w holds lerp value for blending\n  #endif\n  #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n   
          giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n    giInput.probePosition[0]
          = unity_SpecCube0_ProbePosition;\n    giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n   
          giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n    giInput.probePosition[1]
          = unity_SpecCube1_ProbePosition;\n  #endif\n  LightingLambert_GI(o, giInput,
          gi);\n\n  // call lighting function to output g-buffer\n  outEmission =
          LightingLambert_Deferred (o, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n 
          #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n    outShadowMask
          = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n  #endif\n  #ifndef
          UNITY_HDR_ON\n  outEmission.rgb = exp2(-outEmission.rgb);\n  #endif\n 
          SplatmapFinalGBuffer (surfIN, o, outGBuffer0, outGBuffer1, outGBuffer2,
          outEmission);\n}\n\n\n#endif\n\n\n"
        m_AssetPath: Assets/DefaultResourcesExtra/TerrainShaders/Splats
        m_PlatformMask: 4294966271
        m_HardwareTierVariantsMask: 0
        m_StartLine: 200
        m_TypesMask: 3
        m_IncludesHash:
          serializedVersion: 2
          Hash: b2f21b964a0684e6b299d78f0232fab3
        m_CodeHash:
          serializedVersion: 2
          Hash: 00000000000000000000000000000000
        m_FromOther: 1
        m_ForceSyncCompilation: 0
        m_Language: 0
        m_VariantsUserGlobal0:
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal1:
        - - __
          - INSTANCING_ON
        m_VariantsUserGlobal2: []
        m_VariantsUserGlobal3: []
        m_VariantsUserGlobal4: []
        m_VariantsUserGlobal5: []
        m_VariantsUserGlobal6: []
        m_VariantsUserLocal0: []
        m_VariantsUserLocal1: []
        m_VariantsUserLocal2: []
        m_VariantsUserLocal3: []
        m_VariantsUserLocal4: []
        m_VariantsUserLocal5: []
        m_VariantsUserLocal6: []
        m_VariantsBuiltin0:
        - []
        - - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
        - - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
        - - LIGHTMAP_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        m_VariantsBuiltin1:
        - []
        - - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
        - - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
        - - LIGHTMAP_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
          - LIGHTPROBE_SH
        - - LIGHTMAP_ON
          - DIRLIGHTMAP_COMBINED
          - DYNAMICLIGHTMAP_ON
          - UNITY_HDR_ON
          - SHADOWS_SHADOWMASK
        m_VariantsBuiltin2: []
        m_VariantsBuiltin3: []
        m_VariantsBuiltin4: []
        m_VariantsBuiltin5: []
        m_VariantsBuiltin6: []
        m_BaseRequirements: 33
        m_KeywordTargetInfo:
        - keywordName: SHADOWS_SOFT
          requirements: 227
        - keywordName: DIRLIGHTMAP_COMBINED
          requirements: 227
        - keywordName: DIRLIGHTMAP_SEPARATE
          requirements: 227
        - keywordName: DYNAMICLIGHTMAP_ON
          requirements: 227
        - keywordName: SHADOWS_SCREEN
          requirements: 227
        - keywordName: INSTANCING_ON
          requirements: 2048
        - keywordName: PROCEDURAL_INSTANCING_ON
          requirements: 16384
        - keywordName: STEREO_MULTIVIEW_ON
          requirements: 4075
        - keywordName: STEREO_INSTANCING_ON
          requirements: 4075
        m_NonStrippedUserKeywords: FOG_LINEAR FOG_EXP FOG_EXP2 INSTANCING_ON
        m_BuiltinKeywords: LIGHTPROBE_SH DYNAMICLIGHTMAP_ON SHADOWS_SHADOWMASK LIGHTMAP_ON
          DIRLIGHTMAP_COMBINED UNITY_HDR_ON
    m_MeshComponentsFromSnippets: 0
    m_HasSurfaceShaders: 0
    m_HasFixedFunctionShaders: 0
